(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react')) :
  typeof define === 'function' && define.amd ? define(['exports', 'react'], factory) :
  (global = global || self, factory(global.ReactQuery = {}, global.React));
}(this, (function (exports, React) { 'use strict';

  React = React && Object.prototype.hasOwnProperty.call(React, 'default') ? React['default'] : React;

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  var statusIdle = 'idle';
  var statusLoading = 'loading';
  var statusError = 'error';
  var statusSuccess = 'success';
  var _uid = 0;
  var uid = function uid() {
    return _uid++;
  };
  var cancelledError = {};
  var isServer = typeof window === 'undefined';
  function noop() {
    return void 0;
  }
  function identity(d) {
    return d;
  }
  var Console = console || {
    error: noop,
    warn: noop,
    log: noop
  };
  function setConsole(c) {
    Console = c;
  }
  function functionalUpdate(updater, old) {
    return typeof updater === 'function' ? updater(old) : updater;
  }
  function stableStringifyReplacer(_, value) {
    return isObject(value) ? Object.assign.apply(Object, [{}].concat(Object.keys(value).sort().map(function (key) {
      var _ref;

      return _ref = {}, _ref[key] = value[key], _ref;
    }))) : value;
  }
  function stableStringify(obj) {
    return JSON.stringify(obj, stableStringifyReplacer);
  }
  function isObject(a) {
    return a && typeof a === 'object' && !Array.isArray(a);
  }
  function deepIncludes(a, b) {
    if (a === b) {
      return true;
    }

    if (typeof a !== typeof b) {
      return false;
    }

    if (typeof a === 'object') {
      return !Object.keys(b).some(function (key) {
        return !deepIncludes(a[key], b[key]);
      });
    }

    return false;
  }
  function isDocumentVisible() {
    return typeof document === 'undefined' || document.visibilityState === undefined || document.visibilityState === 'visible' || document.visibilityState === 'prerender';
  }
  function isOnline() {
    return navigator.onLine === undefined || navigator.onLine;
  }
  function getQueryArgs(args) {
    if (isObject(args[0])) {
      var _args$ = args[0],
          _queryKey = _args$.queryKey,
          _queryFn = _args$.queryFn,
          _config = _args$.config;
      args = [_queryKey, _queryFn, _config].concat(args.slice(1));
    } else if (isObject(args[1])) {
      var _args = args,
          _queryKey2 = _args[0],
          _config2 = _args[1],
          _rest = _args.slice(2);

      args = [_queryKey2, undefined, _config2].concat(_rest);
    }

    var _args2 = args,
        queryKey = _args2[0],
        queryFn = _args2[1],
        _args2$ = _args2[2],
        config = _args2$ === void 0 ? {} : _args2$,
        rest = _args2.slice(3);

    queryFn = queryFn || config.queryFn;
    return [queryKey, queryFn ? _extends({}, config, {
      queryFn: queryFn
    }) : config].concat(rest);
  } // This deep-equal is directly based on https://github.com/epoberezkin/fast-deep-equal.
  // The parts for comparing any non-JSON-supported values has been removed

  function deepEqual(a, b) {
    if (a === b) return true;

    if (a && b && typeof a == 'object' && typeof b == 'object') {
      var length, i, keys;

      if (Array.isArray(a)) {
        length = a.length; // eslint-disable-next-line eqeqeq

        if (length != b.length) return false;

        for (i = length; i-- !== 0;) {
          if (!deepEqual(a[i], b[i])) return false;
        }

        return true;
      }

      if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
      keys = Object.keys(a);
      length = keys.length;
      if (length !== Object.keys(b).length) return false;

      for (i = length; i-- !== 0;) {
        if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
      }

      for (i = length; i-- !== 0;) {
        var key = keys[i];
        if (!deepEqual(a[key], b[key])) return false;
      }

      return true;
    } // true if both NaN, false otherwise
    // eslint-disable-next-line no-self-compare


    return a !== a && b !== b;
  }
  function getStatusBools(status) {
    return {
      isLoading: status === statusLoading,
      isSuccess: status === statusSuccess,
      isError: status === statusError,
      isIdle: status === statusIdle
    };
  }

  var DEFAULT_CONFIG = {
    shared: {
      suspense: false
    },
    queries: {
      queryKeySerializerFn: defaultQueryKeySerializerFn,
      queryFn: undefined,
      initialStale: undefined,
      enabled: true,
      retry: 3,
      retryDelay: function retryDelay(attemptIndex) {
        return Math.min(1000 * Math.pow(2, attemptIndex), 30000);
      },
      staleTime: 0,
      cacheTime: 5 * 60 * 1000,
      refetchOnWindowFocus: true,
      refetchInterval: false,
      queryFnParamsFilter: identity,
      refetchOnMount: true,
      isDataEqual: deepEqual,
      onError: noop,
      onSuccess: noop,
      onSettled: noop,
      useErrorBoundary: false
    },
    mutations: {
      throwOnError: false,
      onMutate: noop,
      onError: noop,
      onSuccess: noop,
      onSettled: noop,
      useErrorBoundary: false
    }
  };
  var defaultConfigRef = {
    current: DEFAULT_CONFIG
  };
  function defaultQueryKeySerializerFn(queryKey) {
    if (!queryKey) {
      return [];
    }

    if (!Array.isArray(queryKey)) {
      queryKey = [queryKey];
    }

    if (queryKey.some(function (d) {
      return typeof d === 'function';
    })) {
      throw new Error('A valid query key is required!');
    }

    var queryHash = stableStringify(queryKey);
    queryKey = JSON.parse(queryHash);

    if (!queryHash) {
      return [];
    }

    return [queryHash, queryKey];
  }

  function _empty() {}

  function _awaitIgnored(value, direct) {
    if (!direct) {
      return value && value.then ? value.then(_empty) : Promise.resolve();
    }
  }

  function _invoke(body, then) {
    var result = body();

    if (result && result.then) {
      return result.then(then);
    }

    return then(result);
  }

  function _catch(body, recover) {
    try {
      var result = body();
    } catch (e) {
      return recover(e);
    }

    if (result && result.then) {
      return result.then(void 0, recover);
    }

    return result;
  }

  function _continueIgnored(value) {
    if (value && value.then) {
      return value.then(_empty);
    }
  }

  function _async(f) {
    return function () {
      for (var args = [], i = 0; i < arguments.length; i++) {
        args[i] = arguments[i];
      }

      try {
        return Promise.resolve(f.apply(this, args));
      } catch (e) {
        return Promise.reject(e);
      }
    };
  }

  function makeQueryInstance(query, onStateUpdate) {
    var instance = {
      id: uid(),
      onStateUpdate: onStateUpdate
    };

    instance.clearInterval = function () {
      clearInterval(instance.refetchIntervalId);
      delete instance.refetchIntervalId;
    };

    instance.updateConfig = function (config) {
      var oldConfig = instance.config; // Update the config

      instance.config = config;

      if (!isServer) {
        if ((oldConfig == null ? void 0 : oldConfig.refetchInterval) === config.refetchInterval) {
          return;
        }

        query.clearIntervals();
        var minInterval = Math.min.apply(Math, query.instances.map(function (d) {
          return d.config.refetchInterval || Infinity;
        }));

        if (!instance.refetchIntervalId && minInterval > 0 && minInterval < Infinity) {
          instance.refetchIntervalId = setInterval(function () {
            if (query.instances.some(function (instance) {
              return instance.config.enabled;
            }) && (isDocumentVisible() || query.instances.some(function (instance) {
              return instance.config.refetchIntervalInBackground;
            }))) {
              query.fetch();
            }
          }, minInterval);
        }
      }
    };

    instance.run = _async(function () {
      return _continueIgnored(_catch(function () {
        // Perform the refetch for this query if necessary
        return _invoke(function () {
          if (query.config.enabled && // Don't auto refetch if disabled
          !query.wasSuspended && // Don't double refetch for suspense
          query.state.isStale && ( // Only refetch if stale
          query.config.refetchOnMount || query.instances.length === 1)) {
            return _awaitIgnored(query.fetch());
          }
        }, function () {
          query.wasSuspended = false;
        });
      }, function (error) {
        Console.error(error);
      }));
    });

    instance.unsubscribe = function () {
      query.instances = query.instances.filter(function (d) {
        return d.id !== instance.id;
      });

      if (!query.instances.length) {
        instance.clearInterval();
        query.cancel();

        if (!isServer) {
          // Schedule garbage collection
          query.scheduleGarbageCollection();
        }
      }
    };

    return instance;
  }

  function _empty$1() {}

  var actionInit = 'Init';

  function _awaitIgnored$1(value, direct) {
    if (!direct) {
      return value && value.then ? value.then(_empty$1) : Promise.resolve();
    }
  }

  var actionFailed = 'Failed';

  function _catch$1(body, recover) {
    try {
      var result = body();
    } catch (e) {
      return recover(e);
    }

    if (result && result.then) {
      return result.then(void 0, recover);
    }

    return result;
  }

  var actionMarkStale = 'MarkStale';

  function _continueIgnored$1(value) {
    if (value && value.then) {
      return value.then(_empty$1);
    }
  }

  var actionMarkGC = 'MarkGC';

  function _async$1(f) {
    return function () {
      for (var args = [], i = 0; i < arguments.length; i++) {
        args[i] = arguments[i];
      }

      try {
        return Promise.resolve(f.apply(this, args));
      } catch (e) {
        return Promise.reject(e);
      }
    };
  }

  var actionFetch = 'Fetch';

  function _await(value, then, direct) {
    if (direct) {
      return then ? then(value) : value;
    }

    if (!value || !value.then) {
      value = Promise.resolve(value);
    }

    return then ? value.then(then) : value;
  }

  var actionSuccess = 'Success';

  function _invoke$1(body, then) {
    var result = body();

    if (result && result.then) {
      return result.then(then);
    }

    return then(result);
  }

  var actionError = 'Error';

  function _invokeIgnored(body) {
    var result = body();

    if (result && result.then) {
      return result.then(_empty$1);
    }
  }

  var actionSetState = 'SetState';

  function _settle(pact, state, value) {
    if (!pact.s) {
      if (value instanceof _Pact) {
        if (value.s) {
          if (state & 1) {
            state = value.s;
          }

          value = value.v;
        } else {
          value.o = _settle.bind(null, pact, state);
          return;
        }
      }

      if (value && value.then) {
        value.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));
        return;
      }

      pact.s = state;
      pact.v = value;
      var observer = pact.o;

      if (observer) {
        observer(pact);
      }
    }
  }

  var _Pact = /*#__PURE__*/function () {
    function _Pact() {}

    _Pact.prototype.then = function (onFulfilled, onRejected) {
      var result = new _Pact();
      var state = this.s;

      if (state) {
        var callback = state & 1 ? onFulfilled : onRejected;

        if (callback) {
          try {
            _settle(result, 1, callback(this.v));
          } catch (e) {
            _settle(result, 2, e);
          }

          return result;
        } else {
          return this;
        }
      }

      this.o = function (_this) {
        try {
          var value = _this.v;

          if (_this.s & 1) {
            _settle(result, 1, onFulfilled ? onFulfilled(value) : value);
          } else if (onRejected) {
            _settle(result, 1, onRejected(value));
          } else {
            _settle(result, 2, value);
          }
        } catch (e) {
          _settle(result, 2, e);
        }
      };

      return result;
    };

    return _Pact;
  }();

  function _isSettledPact(thenable) {
    return thenable instanceof _Pact && thenable.s & 1;
  }

  function _do(body, test) {
    var awaitBody;

    do {
      var result = body();

      if (result && result.then) {
        if (_isSettledPact(result)) {
          result = result.v;
        } else {
          awaitBody = true;
          break;
        }
      }

      var shouldContinue = test();

      if (_isSettledPact(shouldContinue)) {
        shouldContinue = shouldContinue.v;
      }

      if (!shouldContinue) {
        return result;
      }
    } while (!shouldContinue.then);

    var pact = new _Pact();

    var reject = _settle.bind(null, pact, 2);

    (awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);
    return pact;

    function _resumeAfterBody(value) {
      result = value;

      for (;;) {
        shouldContinue = test();

        if (_isSettledPact(shouldContinue)) {
          shouldContinue = shouldContinue.v;
        }

        if (!shouldContinue) {
          break;
        }

        if (shouldContinue.then) {
          shouldContinue.then(_resumeAfterTest).then(void 0, reject);
          return;
        }

        result = body();

        if (result && result.then) {
          if (_isSettledPact(result)) {
            result = result.v;
          } else {
            result.then(_resumeAfterBody).then(void 0, reject);
            return;
          }
        }
      }

      _settle(pact, 1, result);
    }

    function _resumeAfterTest(shouldContinue) {
      if (shouldContinue) {
        do {
          result = body();

          if (result && result.then) {
            if (_isSettledPact(result)) {
              result = result.v;
            } else {
              result.then(_resumeAfterBody).then(void 0, reject);
              return;
            }
          }

          shouldContinue = test();

          if (_isSettledPact(shouldContinue)) {
            shouldContinue = shouldContinue.v;
          }

          if (!shouldContinue) {
            _settle(pact, 1, result);

            return;
          }
        } while (!shouldContinue.then);

        shouldContinue.then(_resumeAfterTest).then(void 0, reject);
      } else {
        _settle(pact, 1, result);
      }
    }
  }

  function _continue(value, then) {
    return value && value.then ? value.then(then) : then(value);
  }

  function _rethrow(thrown, value) {
    if (thrown) throw value;
    return value;
  }

  function _finallyRethrows(body, finalizer) {
    try {
      var result = body();
    } catch (e) {
      return finalizer(true, e);
    }

    if (result && result.then) {
      return result.then(finalizer.bind(null, false), finalizer.bind(null, true));
    }

    return finalizer(false, result);
  }

  function makeQuery(_ref) {
    var _config$initialStale;

    var queryCache = _ref.queryCache,
        queryKey = _ref.queryKey,
        queryHash = _ref.queryHash,
        config = _ref.config,
        notifyGlobalListeners = _ref.notifyGlobalListeners;
    var initialData = typeof config.initialData === 'function' ? config.initialData() : config.initialData;
    var hasInitialData = typeof initialData !== 'undefined';
    var isStale = !config.enabled || (typeof config.initialStale === 'function' ? config.initialStale() : (_config$initialStale = config.initialStale) != null ? _config$initialStale : !hasInitialData);
    var initialStatus = hasInitialData ? statusSuccess : config.enabled ? statusLoading : statusIdle;
    var query = {
      queryKey: queryKey,
      queryHash: queryHash,
      config: config,
      instances: [],
      state: queryReducer(undefined, {
        type: actionInit,
        initialStatus: initialStatus,
        initialData: initialData,
        hasInitialData: hasInitialData,
        isStale: isStale
      })
    };

    query.dispatch = function (action) {
      query.state = queryReducer(query.state, action);
      query.instances.forEach(function (d) {
        return d.onStateUpdate(query.state);
      });
      notifyGlobalListeners();
    };

    query.scheduleStaleTimeout = function () {
      if (isServer) return;
      clearTimeout(query.staleTimeout);

      if (query.config.staleTime === Infinity) {
        return;
      }

      query.staleTimeout = setTimeout(function () {
        if (queryCache.getQuery(query.queryKey)) {
          query.invalidate();
        }
      }, query.config.staleTime);
    };

    query.invalidate = function () {
      clearTimeout(query.staleTimeout);
      query.dispatch({
        type: actionMarkStale
      });
    };

    query.scheduleGarbageCollection = function () {
      if (!queryCache.queries[query.queryHash]) return;

      if (query.config.cacheTime === Infinity) {
        return;
      }

      query.dispatch({
        type: actionMarkGC
      });
      query.cacheTimeout = setTimeout(function () {
        queryCache.removeQueries(function (d) {
          return d.state.markedForGarbageCollection && d.queryHash === query.queryHash;
        });
      }, typeof query.state.data === 'undefined' && query.state.status !== 'error' ? 0 : query.config.cacheTime);
    };

    query.refetch = _async$1(function () {
      return _continueIgnored$1(_catch$1(function () {
        return _awaitIgnored$1(query.fetch());
      }, function (error) {
        Console.error(error);
      }));
    });

    query.heal = function () {
      // Stop the query from being garbage collected
      clearTimeout(query.cacheTimeout); // Mark the query as not cancelled

      query.cancelled = null;
    };

    query.cancel = function () {
      query.cancelled = cancelledError;

      if (query.cancelPromises) {
        query.cancelPromises();
      }

      delete query.promise;
    };

    query.clearIntervals = function () {
      query.instances.forEach(function (instance) {
        instance.clearInterval();
      });
    };

    query.setState = function (updater) {
      return query.dispatch({
        type: actionSetState,
        updater: updater
      });
    };

    query.setData = function (updater) {
      // Set data and mark it as cached
      query.dispatch({
        type: actionSuccess,
        updater: updater
      }); // Schedule a fresh invalidation!

      query.scheduleStaleTimeout();
    };

    query.clear = function () {
      clearTimeout(query.staleTimeout);
      clearTimeout(query.cacheTimeout);
      clearTimeout(query.retryTimeout);
      query.clearIntervals();
      query.cancel();
      query.dispatch = noop;
      delete queryCache.queries[query.queryHash];
      notifyGlobalListeners();
    };

    query.subscribe = function (onStateUpdate) {
      if (onStateUpdate === void 0) {
        onStateUpdate = noop;
      }

      var instance = makeQueryInstance(query, onStateUpdate);
      query.instances.push(instance);
      query.heal();
      return instance;
    }; // Set up the core fetcher function


    var tryFetchData = _async$1(function (fn) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      return _catch$1(function () {
        // Perform the query
        var promise = fn.apply(void 0, query.config.queryFnParamsFilter(args));

        query.cancelPromises = function () {
          return promise.cancel == null ? void 0 : promise.cancel();
        };

        return _await(promise, function (data) {
          delete query.shouldContinueRetryOnFocus;
          delete query.cancelPromises;
          if (query.cancelled) throw query.cancelled;
          return data;
        });
      }, function (error) {
        var _exit = false;
        delete query.cancelPromises;
        if (query.cancelled) throw query.cancelled; // If we fail, increase the failureCount

        query.dispatch({
          type: actionFailed
        }); // Do we need to retry the request?

        return _invoke$1(function () {
          if (query.config.retry === true || query.state.failureCount <= query.config.retry || typeof query.config.retry === 'function' && query.config.retry(query.state.failureCount, error)) {
            // Only retry if the document is visible
            if (!isDocumentVisible()) {
              // set this flag to continue retries on focus
              query.shouldContinueRetryOnFocus = true; // Resolve a

              _exit = true;
              return new Promise(noop);
            }

            delete query.shouldContinueRetryOnFocus; // Determine the retryDelay

            var delay = functionalUpdate(query.config.retryDelay, query.state.failureCount); // Return a new promise with the retry

            _exit = true;
            return _await(new Promise(function (resolve, reject) {
              // Keep track of the retry timeout
              query.retryTimeout = setTimeout(_async$1(function () {
                return query.cancelled ? reject(query.cancelled) : _catch$1(function () {
                  return _await(tryFetchData.apply(void 0, [fn].concat(args)), function (data) {
                    if (query.cancelled) return reject(query.cancelled);
                    resolve(data);
                  });
                }, function (error) {
                  if (query.cancelled) return reject(query.cancelled);
                  reject(error);
                });
              }), delay);
            }));
          }
        }, function (_result) {
          if (_exit) return _result;
          throw error;
        });
      });
    });

    query.fetch = _async$1(function (_temp) {
      var _ref2 = _temp === void 0 ? {} : _temp,
          fetchMore = _ref2.fetchMore;

      var queryFn = query.config.queryFn;

      if (!queryFn) {
        return;
      }

      if (query.config.infinite) {
        var originalQueryFn = queryFn;
        queryFn = _async$1(function () {
          var _interrupt = false;
          var data = [];
          var pageVariables = [].concat(query.pageVariables);
          var rebuiltPageVariables = [];
          return _continue(_do(function () {
            var args = pageVariables.shift();
            return _invokeIgnored(function () {
              if (!data.length) {
                var _push3 = data.push;
                // the first page query doesn't need to be rebuilt
                return _await(originalQueryFn.apply(void 0, args), function (_originalQueryFn) {
                  _push3.call(data, _originalQueryFn);

                  rebuiltPageVariables.push(args);
                });
              } else {
                // get an up-to-date cursor based on the previous data set
                var nextCursor = query.config.getFetchMore(data[data.length - 1], data); // break early if there's no next cursor
                // otherwise we'll start from the beginning
                // which will cause unwanted duplication

                if (!nextCursor) {
                  _interrupt = true;
                  return;
                }

                var pageArgs = [].concat(args.slice(0, -1), [nextCursor]);
                var _push4 = data.push;
                return _await(originalQueryFn.apply(void 0, pageArgs), function (_originalQueryFn2) {
                  _push4.call(data, _originalQueryFn2);

                  rebuiltPageVariables.push(pageArgs);
                });
              }
            });
          }, function () {
            return !_interrupt && !!pageVariables.length;
          }), function () {
            query.state.canFetchMore = query.config.getFetchMore(data[data.length - 1], data);
            query.pageVariables = rebuiltPageVariables;
            return data;
          });
        });

        if (fetchMore) {
          queryFn = _async$1(function () {
            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              args[_key2] = arguments[_key2];
            }

            var fetchMoreInfo = fetchMore.fetchMoreInfo,
                previous = fetchMore.previous;
            return _finallyRethrows(function () {
              query.setState(function (old) {
                return _extends({}, old, {
                  isFetchingMore: previous ? 'previous' : 'next'
                });
              });
              var newArgs = [].concat(args, [fetchMoreInfo]);
              query.pageVariables[previous ? 'unshift' : 'push'](newArgs);
              return _await(originalQueryFn.apply(void 0, newArgs), function (newData) {
                var data = previous ? [newData].concat(query.state.data) : [].concat(query.state.data, [newData]);
                query.state.canFetchMore = query.config.getFetchMore(newData, data);
                return data;
              });
            }, function (_wasThrown, _result3) {
              query.setState(function (old) {
                return _extends({}, old, {
                  isFetchingMore: false
                });
              });
              return _rethrow(_wasThrown, _result3);
            });
          });
        }
      } // Create a new promise for the query cache if necessary


      if (!query.promise) {
        query.promise = _async$1(function () {
          // If there are any retries pending for this query, kill them
          query.cancelled = null;

          var getCallbackInstances = function getCallbackInstances() {
            var callbackInstances = [].concat(query.instances);

            if (query.wasSuspended) {
              callbackInstances.unshift(query.fallbackInstance);
            }

            return callbackInstances;
          };

          return _catch$1(function () {
            // Set up the query refreshing state
            query.dispatch({
              type: actionFetch
            }); // Try to get the data

            return _await(tryFetchData.apply(void 0, [queryFn].concat(query.queryKey)), function (data) {
              query.setData(function (old) {
                return query.config.isDataEqual(old, data) ? old : data;
              });
              getCallbackInstances().forEach(function (instance) {
                return instance.config.onSuccess && instance.config.onSuccess(query.state.data);
              });
              getCallbackInstances().forEach(function (instance) {
                return instance.config.onSettled && instance.config.onSettled(query.state.data, null);
              });
              delete query.promise;
              return data;
            });
          }, function (error) {
            query.dispatch({
              type: actionError,
              cancelled: error === query.cancelled,
              error: error
            });
            delete query.promise;

            if (error !== query.cancelled) {
              getCallbackInstances().forEach(function (instance) {
                return instance.config.onError && instance.config.onError(error);
              });
              getCallbackInstances().forEach(function (instance) {
                return instance.config.onSettled && instance.config.onSettled(undefined, error);
              });
              throw error;
            }
          });
        })();
      }

      return query.promise;
    });

    if (query.config.infinite) {
      query.fetchMore = function (fetchMoreInfo, _temp2) {
        if (fetchMoreInfo === void 0) {
          fetchMoreInfo = query.state.canFetchMore;
        }

        var _ref3 = _temp2 === void 0 ? {} : _temp2,
            _ref3$previous = _ref3.previous,
            previous = _ref3$previous === void 0 ? false : _ref3$previous;

        return query.fetch({
          fetchMore: {
            fetchMoreInfo: fetchMoreInfo,
            previous: previous
          }
        });
      };
    }

    return query;
  }
  function queryReducer(state, action) {
    var newState = switchActions(state, action);
    return Object.assign(newState, getStatusBools(newState.status));
  }

  function switchActions(state, action) {
    switch (action.type) {
      case actionInit:
        return {
          status: action.initialStatus,
          error: null,
          isFetching: action.initialStatus === 'loading',
          failureCount: 0,
          isStale: action.isStale,
          markedForGarbageCollection: false,
          data: action.initialData,
          updatedAt: action.hasInitialData ? Date.now() : 0
        };

      case actionFailed:
        return _extends({}, state, {
          failureCount: state.failureCount + 1
        });

      case actionMarkStale:
        return _extends({}, state, {
          isStale: true
        });

      case actionMarkGC:
        {
          return _extends({}, state, {
            markedForGarbageCollection: true
          });
        }

      case actionFetch:
        return _extends({}, state, {
          status: typeof state.data !== 'undefined' ? statusSuccess : statusLoading,
          isFetching: true,
          failureCount: 0
        });

      case actionSuccess:
        return _extends({}, state, {
          status: statusSuccess,
          data: functionalUpdate(action.updater, state.data),
          error: null,
          isStale: false,
          isFetching: false,
          updatedAt: Date.now(),
          failureCount: 0
        });

      case actionError:
        return _extends({}, state, {
          isFetching: false,
          isStale: true
        }, !action.cancelled && {
          status: statusError,
          error: action.error,
          throwInErrorBoundary: true
        });

      case actionSetState:
        return functionalUpdate(action.updater, state);

      default:
        throw new Error();
    }
  }

  function _await$1(value, then, direct) {
    if (direct) {
      return then ? then(value) : value;
    }

    if (!value || !value.then) {
      value = Promise.resolve(value);
    }

    return then ? value.then(then) : value;
  }

  function _catch$2(body, recover) {
    try {
      var result = body();
    } catch (e) {
      return recover(e);
    }

    if (result && result.then) {
      return result.then(void 0, recover);
    }

    return result;
  }

  function _async$2(f) {
    return function () {
      for (var args = [], i = 0; i < arguments.length; i++) {
        args[i] = arguments[i];
      }

      try {
        return Promise.resolve(f.apply(this, args));
      } catch (e) {
        return Promise.reject(e);
      }
    };
  }

  function _empty$2() {}

  function _awaitIgnored$2(value, direct) {
    if (!direct) {
      return value && value.then ? value.then(_empty$2) : Promise.resolve();
    }
  }

  function _invoke$2(body, then) {
    var result = body();

    if (result && result.then) {
      return result.then(then);
    }

    return then(result);
  }

  var queryCache = makeQueryCache();
  var queryCaches = [queryCache];
  function makeQueryCache(_temp) {
    var _ref = _temp === void 0 ? {} : _temp,
        _ref$frozen = _ref.frozen,
        frozen = _ref$frozen === void 0 ? isServer : _ref$frozen,
        defaultConfig = _ref.defaultConfig;

    // A frozen cache does not add new queries to the cache
    var globalListeners = [];
    var configRef = defaultConfig ? {
      current: _extends({}, defaultConfigRef.current, defaultConfig)
    } : defaultConfigRef;
    var queryCache = {
      queries: {},
      isFetching: 0
    };

    var notifyGlobalListeners = function notifyGlobalListeners() {
      queryCache.isFetching = Object.values(queryCache.queries).reduce(function (acc, query) {
        return query.state.isFetching ? acc + 1 : acc;
      }, 0);
      globalListeners.forEach(function (d) {
        return d(queryCache);
      });
    };

    queryCache.subscribe = function (cb) {
      globalListeners.push(cb);
      return function () {
        globalListeners.splice(globalListeners.indexOf(cb), 1);
      };
    };

    queryCache.clear = function (_temp2) {
      var _ref2 = _temp2 === void 0 ? {} : _temp2,
          _ref2$notify = _ref2.notify,
          notify = _ref2$notify === void 0 ? true : _ref2$notify;

      Object.values(queryCache.queries).forEach(function (query) {
        return query.clear();
      });
      queryCache.queries = {};

      if (notify) {
        notifyGlobalListeners();
      }
    };

    queryCache.getQueries = function (predicate, _temp3) {
      var _ref3 = _temp3 === void 0 ? {} : _temp3,
          exact = _ref3.exact;

      if (predicate === true) {
        return Object.values(queryCache.queries);
      }

      if (typeof predicate !== 'function') {
        var _configRef$current$qu = configRef.current.queries.queryKeySerializerFn(predicate),
            queryHash = _configRef$current$qu[0],
            queryKey = _configRef$current$qu[1];

        predicate = function predicate(d) {
          return exact ? d.queryHash === queryHash : deepIncludes(d.queryKey, queryKey);
        };
      }

      return Object.values(queryCache.queries).filter(predicate);
    };

    queryCache.getQuery = function (queryKey) {
      return queryCache.getQueries(queryKey, {
        exact: true
      })[0];
    };

    queryCache.getQueryData = function (queryKey) {
      var _queryCache$getQuery;

      return (_queryCache$getQuery = queryCache.getQuery(queryKey)) == null ? void 0 : _queryCache$getQuery.state.data;
    };

    queryCache.removeQueries = function () {
      queryCache.getQueries.apply(queryCache, arguments).forEach(function (query) {
        return query.clear();
      });
    };

    queryCache.cancelQueries = function () {
      queryCache.getQueries.apply(queryCache, arguments).forEach(function (query) {
        return query.cancel();
      });
    };

    queryCache.invalidateQueries = _async$2(function (predicate, _temp4) {
      var _ref4 = _temp4 === void 0 ? {} : _temp4,
          _ref4$refetchActive = _ref4.refetchActive,
          refetchActive = _ref4$refetchActive === void 0 ? true : _ref4$refetchActive,
          _ref4$refetchInactive = _ref4.refetchInactive,
          refetchInactive = _ref4$refetchInactive === void 0 ? false : _ref4$refetchInactive,
          exact = _ref4.exact,
          throwOnError = _ref4.throwOnError;

      return _catch$2(function () {
        return _await$1(Promise.all(queryCache.getQueries(predicate, {
          exact: exact
        }).map(function (query) {
          if (query.instances.length) {
            if (refetchActive && query.instances.some(function (instance) {
              return instance.config.enabled;
            })) {
              return query.fetch();
            }
          } else {
            if (refetchInactive) {
              return query.fetch();
            }
          }

          return query.invalidate();
        })));
      }, function (err) {
        if (throwOnError) {
          throw err;
        }
      });
    });

    queryCache.resetErrorBoundaries = function () {
      queryCache.getQueries(true).forEach(function (query) {
        query.state.throwInErrorBoundary = false;
      });
    };

    queryCache.buildQuery = function (userQueryKey, config) {
      if (config === void 0) {
        config = {};
      }

      config = _extends({}, configRef.current.shared, configRef.current.queries, config);

      var _config$queryKeySeria = config.queryKeySerializerFn(userQueryKey),
          queryHash = _config$queryKeySeria[0],
          queryKey = _config$queryKeySeria[1];

      var query = queryCache.queries[queryHash];

      if (query) {
        Object.assign(query, {
          config: config
        });
      } else {
        query = makeQuery({
          queryCache: queryCache,
          queryKey: queryKey,
          queryHash: queryHash,
          config: config,
          notifyGlobalListeners: notifyGlobalListeners
        });

        if (config.infinite) {
          if (typeof query.state.canFetchMore === 'undefined' && typeof query.state.data !== 'undefined') {
            query.state.canFetchMore = config.getFetchMore(query.state.data[query.state.data.length - 1], query.state.data);
          } // Here we seed the pageVariabes for the query


          if (!query.pageVariables) {
            query.pageVariables = [[].concat(query.queryKey)];
          }
        } // If the query started with data, schedule
        // a stale timeout


        if (!isServer && query.state.data) {
          query.scheduleStaleTimeout(); // Simulate a query healing process

          query.heal(); // Schedule for garbage collection in case
          // nothing subscribes to this query

          query.scheduleGarbageCollection();
        }

        if (!frozen) {
          queryCache.queries[queryHash] = query;

          if (isServer) {
            notifyGlobalListeners();
          } else {
            // Here, we setTimeout so as to not trigger
            // any setState's in parent components in the
            // middle of the render phase.
            setTimeout(function () {
              notifyGlobalListeners();
            });
          }
        }
      }

      query.fallbackInstance = {
        config: {
          onSuccess: query.config.onSuccess,
          onError: query.config.onError,
          onSettled: query.config.onSettled
        }
      };
      return query;
    };

    queryCache.prefetchQuery = _async$2(function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      if (isObject(args[1]) && (args[1].hasOwnProperty('throwOnError') || args[1].hasOwnProperty('force'))) {
        args[3] = args[1];
        args[1] = undefined;
        args[2] = undefined;
      }

      var _getQueryArgs = getQueryArgs(args),
          queryKey = _getQueryArgs[0],
          config = _getQueryArgs[1],
          _getQueryArgs$ = _getQueryArgs[2];

      _getQueryArgs$ = _getQueryArgs$ === void 0 ? {} : _getQueryArgs$;
      var force = _getQueryArgs$.force,
          throwOnError = _getQueryArgs$.throwOnError;
      return _catch$2(function () {
        var query = queryCache.buildQuery(queryKey, config);
        return _invoke$2(function () {
          if (force || query.state.isStale) {
            return _awaitIgnored$2(query.fetch());
          }
        }, function () {
          return query.state.data;
        });
      }, function (err) {
        if (throwOnError) {
          throw err;
        }

        Console.error(err);
      });
    });

    queryCache.setQueryData = function (queryKey, updater, config) {
      if (config === void 0) {
        config = {};
      }

      var query = queryCache.getQuery(queryKey);

      if (!query) {
        query = queryCache.buildQuery(queryKey, config);
      }

      query.setData(updater);
    };

    return queryCache;
  }

  var visibilityChangeEvent = 'visibilitychange';
  var focusEvent = 'focus';

  var onWindowFocus = function onWindowFocus() {
    if (isDocumentVisible() && isOnline()) {
      queryCaches.forEach(function (queryCache) {
        return queryCache.invalidateQueries(function (query) {
          if (!query.instances.length) {
            return false;
          }

          if (!query.instances.some(function (instance) {
            return instance.config.enabled;
          })) {
            return false;
          }

          if (!query.state.isStale) {
            return false;
          }

          if (query.shouldContinueRetryOnFocus) {
            // delete promise, so refetching will create new one
            delete query.promise;
          }

          return query.config.refetchOnWindowFocus;
        }).catch(Console.error);
      });
    }
  };

  var removePreviousHandler;
  function setFocusHandler(callback) {
    // Unsub the old watcher
    if (removePreviousHandler) {
      removePreviousHandler();
    } // Sub the new watcher


    removePreviousHandler = callback(onWindowFocus);
  }
  setFocusHandler(function (handleFocus) {
    var _window;

    // Listen to visibillitychange and focus
    if (!isServer && ((_window = window) == null ? void 0 : _window.addEventListener)) {
      window.addEventListener(visibilityChangeEvent, handleFocus, false);
      window.addEventListener(focusEvent, handleFocus, false);
      return function () {
        // Be sure to unsubscribe if a new handler is set
        window.removeEventListener(visibilityChangeEvent, handleFocus);
        window.removeEventListener(focusEvent, handleFocus);
      };
    }
  });

  var queryCacheContext = React.createContext(queryCache);
  var useQueryCache = function useQueryCache() {
    return React.useContext(queryCacheContext);
  };
  function ReactQueryCacheProvider(_ref) {
    var queryCache = _ref.queryCache,
        children = _ref.children;
    var resolvedQueryCache = React.useMemo(function () {
      return queryCache || makeQueryCache();
    }, [queryCache]);
    React.useEffect(function () {
      return function () {


        if (queryCache == null) {
          resolvedQueryCache.clear({
            notify: false
          });
        }
      };
    }, [resolvedQueryCache, queryCache]);
    return /*#__PURE__*/React.createElement(queryCacheContext.Provider, {
      value: resolvedQueryCache
    }, children);
  }

  var configContext = React.createContext();
  function useConfigContext() {
    return React.useContext(configContext) || defaultConfigRef.current;
  }
  function ReactQueryConfigProvider(_ref) {
    var config = _ref.config,
        children = _ref.children;
    var configContextValue = useConfigContext();
    var newConfig = React.useMemo(function () {
      var _config$shared = config.shared,
          shared = _config$shared === void 0 ? {} : _config$shared,
          _config$queries = config.queries,
          queries = _config$queries === void 0 ? {} : _config$queries,
          _config$mutations = config.mutations,
          mutations = _config$mutations === void 0 ? {} : _config$mutations;
      var _configContextValue$s = configContextValue.shared,
          contextShared = _configContextValue$s === void 0 ? {} : _configContextValue$s,
          _configContextValue$q = configContextValue.queries,
          contextQueries = _configContextValue$q === void 0 ? {} : _configContextValue$q,
          _configContextValue$m = configContextValue.mutations,
          contextMutations = _configContextValue$m === void 0 ? {} : _configContextValue$m;
      return {
        shared: _extends({}, contextShared, shared),
        queries: _extends({}, contextQueries, queries),
        mutations: _extends({}, contextMutations, mutations)
      };
    }, [config, configContextValue]);
    React.useEffect(function () {
      // restore previous config on unmount
      return function () {
        defaultConfigRef.current = _extends({}, configContextValue || DEFAULT_CONFIG);
      };
    }, [configContextValue]);

    if (!configContextValue) {
      defaultConfigRef.current = newConfig;
    }

    return /*#__PURE__*/React.createElement(configContext.Provider, {
      value: newConfig
    }, children);
  }

  function useGetLatest(obj) {
    var ref = React.useRef();
    ref.current = obj;
    return React.useCallback(function () {
      return ref.current;
    }, []);
  }
  function useQueryArgs(args) {
    var configContext = useConfigContext();

    var _getQueryArgs = getQueryArgs(args),
        queryKey = _getQueryArgs[0],
        config = _getQueryArgs[1],
        rest = _getQueryArgs.slice(2); // Build the final config


    config = _extends({}, configContext.shared, configContext.queries, config);
    return [queryKey, config].concat(rest);
  }
  function useMountedCallback(callback) {
    var mounted = React.useRef(false);
    React[isServer ? 'useEffect' : 'useLayoutEffect'](function () {
      mounted.current = true;
      return function () {
        return mounted.current = false;
      };
    }, []);
    return React.useCallback(function () {
      return mounted.current ? callback.apply(void 0, arguments) : void 0;
    }, [callback]);
  }
  function handleSuspense(queryInfo) {
    if (queryInfo.query.config.suspense || queryInfo.query.config.useErrorBoundary) {
      if (queryInfo.query.state.status === statusError && queryInfo.query.state.throwInErrorBoundary) {
        throw queryInfo.error;
      }

      if (queryInfo.query.config.suspense && queryInfo.status !== statusSuccess && queryInfo.query.config.enabled) {
        queryInfo.query.wasSuspended = true;
        throw queryInfo.query.fetch();
      }
    }
  }

  function useIsFetching() {
    var queryCache = useQueryCache();

    var _React$useReducer = React.useReducer(function (d) {
      return d + 1;
    }, 1),
        state = _React$useReducer[0],
        unsafeRerender = _React$useReducer[1];

    var rerender = useMountedCallback(unsafeRerender);
    var isFetching = React.useMemo(function () {
      return state && queryCache.isFetching;
    }, [queryCache.isFetching, state]);
    var getIsFetching = useGetLatest(isFetching);
    React.useEffect(function () {
      return queryCache.subscribe(function (newCache) {
        if (getIsFetching() !== newCache.isFetching) rerender();
      });
    }, [getIsFetching, queryCache, rerender]);
    return isFetching;
  }

  function _await$2(value, then, direct) {
    if (direct) {
      return then ? then(value) : value;
    }

    if (!value || !value.then) {
      value = Promise.resolve(value);
    }

    return then ? value.then(then) : value;
  }

  var getDefaultState = function getDefaultState() {
    return {
      status: statusIdle,
      data: undefined,
      error: null
    };
  };

  function _catch$3(body, recover) {
    try {
      var result = body();
    } catch (e) {
      return recover(e);
    }

    if (result && result.then) {
      return result.then(void 0, recover);
    }

    return result;
  }

  var actionReset = {};

  function _async$3(f) {
    return function () {
      for (var args = [], i = 0; i < arguments.length; i++) {
        args[i] = arguments[i];
      }

      try {
        return Promise.resolve(f.apply(this, args));
      } catch (e) {
        return Promise.reject(e);
      }
    };
  }

  var actionLoading = {};
  var actionResolve = {};
  var actionReject = {};

  function mutationReducer(state, action) {
    if (action.type === actionReset) {
      return getDefaultState();
    }

    if (action.type === actionLoading) {
      return {
        status: statusLoading
      };
    }

    if (action.type === actionResolve) {
      return {
        status: statusSuccess,
        data: action.data
      };
    }

    if (action.type === actionReject) {
      return {
        status: statusError,
        error: action.error
      };
    }

    throw new Error();
  }

  function useMutation(mutationFn, config) {
    if (config === void 0) {
      config = {};
    }

    var _React$useReducer = React.useReducer(mutationReducer, null, getDefaultState),
        state = _React$useReducer[0],
        unsafeDispatch = _React$useReducer[1];

    var dispatch = useMountedCallback(unsafeDispatch);
    var getMutationFn = useGetLatest(mutationFn);
    var getConfig = useGetLatest(_extends({}, useConfigContext().shared, useConfigContext().mutations, config));
    var latestMutationRef = React.useRef();
    var mutate = React.useCallback(_async$3(function (variables, _temp) {
      var _ref = _temp === void 0 ? {} : _temp,
          _ref$onSuccess = _ref.onSuccess,
          onSuccess = _ref$onSuccess === void 0 ? noop : _ref$onSuccess,
          _ref$onError = _ref.onError,
          onError = _ref$onError === void 0 ? noop : _ref$onError,
          _ref$onSettled = _ref.onSettled,
          onSettled = _ref$onSettled === void 0 ? noop : _ref$onSettled,
          throwOnError = _ref.throwOnError;

      var config = getConfig();
      var mutationId = uid();
      latestMutationRef.current = mutationId;

      var isLatest = function isLatest() {
        return latestMutationRef.current === mutationId;
      };

      var snapshotValue;
      return _catch$3(function () {
        dispatch({
          type: actionLoading
        });
        return _await$2(config.onMutate(variables), function (_config$onMutate) {
          snapshotValue = _config$onMutate;
          return _await$2(getMutationFn()(variables), function (data) {
            if (isLatest()) {
              dispatch({
                type: actionResolve,
                data: data
              });
            }

            return _await$2(config.onSuccess(data, variables), function () {
              return _await$2(onSuccess(data, variables), function () {
                return _await$2(config.onSettled(data, null, variables), function () {
                  return _await$2(onSettled(data, null, variables), function () {
                    return data;
                  });
                });
              });
            });
          });
        });
      }, function (error) {
        Console.error(error);
        return _await$2(config.onError(error, variables, snapshotValue), function () {
          return _await$2(onError(error, variables, snapshotValue), function () {
            return _await$2(config.onSettled(undefined, error, variables, snapshotValue), function () {
              return _await$2(onSettled(undefined, error, variables, snapshotValue), function () {
                if (isLatest()) {
                  dispatch({
                    type: actionReject,
                    error: error
                  });
                }

                if (throwOnError != null ? throwOnError : config.throwOnError) {
                  throw error;
                }
              });
            });
          });
        });
      });
    }), [dispatch, getConfig, getMutationFn]);
    var reset = React.useCallback(function () {
      return dispatch({
        type: actionReset
      });
    }, [dispatch]);
    React.useEffect(function () {
      var _getConfig = getConfig(),
          suspense = _getConfig.suspense,
          useErrorBoundary = _getConfig.useErrorBoundary;

      if ((useErrorBoundary != null ? useErrorBoundary : suspense) && state.error) {
        throw state.error;
      }
    }, [getConfig, state.error]);
    return [mutate, _extends({}, state, {
      reset: reset,
      isIdle: state.status === statusIdle,
      isLoading: state.status === statusLoading,
      isSuccess: state.status === statusSuccess,
      isError: state.status === statusError
    })];
  }

  function useBaseQuery(queryKey, config) {
    if (config === void 0) {
      config = {};
    }

    // Make a rerender function
    var rerender = useMountedCallback(React.useState()[1]); // Get the query cache

    var queryCache = useQueryCache(); // Build the query for use

    var query = queryCache.buildQuery(queryKey, config); // Create a query instance ref

    var instanceRef = React.useRef(); // Subscribe to the query when the subscribe function changes

    React.useEffect(function () {
      instanceRef.current = query.subscribe(function () {
        return rerender({});
      }); // Unsubscribe when things change

      return instanceRef.current.unsubscribe;
    }, [query, rerender]); // Always update the config

    React.useEffect(function () {
      instanceRef.current.updateConfig(config);
    });
    var enabledBool = Boolean(config.enabled); // Run the instance when the query or enabled change

    React.useEffect(function () {

      instanceRef.current.run();
    }, [enabledBool, query]);
    return _extends({}, query, query.state, {
      query: query
    });
  }

  function useQuery() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var query = useBaseQuery.apply(void 0, useQueryArgs(args));
    handleSuspense(query);
    return query;
  }

  // as the query key changes, we keep the results from the
  // last query and use them as placeholder data in the next one
  // We DON'T use it as initial data though. That's important

  function usePaginatedQuery() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _useQueryArgs = useQueryArgs(args),
        queryKey = _useQueryArgs[0],
        _useQueryArgs$ = _useQueryArgs[1],
        config = _useQueryArgs$ === void 0 ? {} : _useQueryArgs$; // Keep track of the latest data result


    var lastDataRef = React.useRef(); // If latestData is there, don't use initialData

    if (typeof lastDataRef.current !== 'undefined') {
      delete config.initialData;
    } // Make the query as normal


    var queryInfo = useBaseQuery(queryKey, config); // If the query is disabled, get rid of the latest data

    if (!queryInfo.query.config.enabled) {
      lastDataRef.current = undefined;
    } // Get the real data and status from the query


    var latestData = queryInfo.data,
        status = queryInfo.status; // If the real query succeeds, and there is data in it,
    // update the latest data

    React.useEffect(function () {
      if (status === 'success' && typeof latestData !== 'undefined') {
        lastDataRef.current = latestData;
      }
    }, [latestData, status]); // Resolved data should be either the real data we're waiting on
    // or the latest placeholder data

    var resolvedData = latestData;

    if (typeof resolvedData === 'undefined') {
      resolvedData = lastDataRef.current;
    } // If we have any data at all from either, we
    // need to make sure the status is success, even though
    // the real query may still be loading


    if (typeof resolvedData !== 'undefined') {
      var overrides = _extends({
        status: 'success'
      }, getStatusBools('success'));

      Object.assign(queryInfo.query.state, overrides);
      Object.assign(queryInfo, overrides);
    }

    var paginatedQueryInfo = _extends({}, queryInfo, {
      resolvedData: resolvedData,
      latestData: latestData
    });

    handleSuspense(paginatedQueryInfo);
    return paginatedQueryInfo;
  }

  //
  function useInfiniteQuery() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _useQueryArgs = useQueryArgs(args),
        queryKey = _useQueryArgs[0],
        config = _useQueryArgs[1];

    config.infinite = true;
    var queryInfo = useBaseQuery(queryKey, config);
    handleSuspense(queryInfo);
    return queryInfo;
  }

  exports.ReactQueryCacheProvider = ReactQueryCacheProvider;
  exports.ReactQueryConfigProvider = ReactQueryConfigProvider;
  exports.deepIncludes = deepIncludes;
  exports.makeQueryCache = makeQueryCache;
  exports.queryCache = queryCache;
  exports.queryCaches = queryCaches;
  exports.setConsole = setConsole;
  exports.setFocusHandler = setFocusHandler;
  exports.stableStringify = stableStringify;
  exports.statusError = statusError;
  exports.statusIdle = statusIdle;
  exports.statusLoading = statusLoading;
  exports.statusSuccess = statusSuccess;
  exports.useInfiniteQuery = useInfiniteQuery;
  exports.useIsFetching = useIsFetching;
  exports.useMutation = useMutation;
  exports.usePaginatedQuery = usePaginatedQuery;
  exports.useQuery = useQuery;
  exports.useQueryCache = useQueryCache;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=react-query.development.js.map
