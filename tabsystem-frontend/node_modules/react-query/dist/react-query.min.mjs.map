{"version":3,"file":"react-query.min.mjs","sources":["../src/core/utils.js","../src/core/config.js","../src/core/queryInstance.js","../src/core/query.js","../src/core/queryCache.js","../src/core/setFocusHandler.js","../src/react/ReactQueryCacheProvider.js","../src/react/ReactQueryConfigProvider.js","../src/react/utils.js","../src/react/useIsFetching.js","../src/react/useMutation.js","../src/react/useBaseQuery.js","../src/react/useQuery.js","../src/react/usePaginatedQuery.js","../src/react/useInfiniteQuery.js"],"sourcesContent":["export const statusIdle = 'idle'\nexport const statusLoading = 'loading'\nexport const statusError = 'error'\nexport const statusSuccess = 'success'\n\nlet _uid = 0\nexport const uid = () => _uid++\nexport const cancelledError = {}\nexport let globalStateListeners = []\nexport const isServer = typeof window === 'undefined'\nexport function noop() {\n  return void 0\n}\nexport function identity(d) {\n  return d\n}\nexport let Console = console || { error: noop, warn: noop, log: noop }\n\nexport function setConsole(c) {\n  Console = c\n}\n\nexport function functionalUpdate(updater, old) {\n  return typeof updater === 'function' ? updater(old) : updater\n}\n\nexport function stableStringifyReplacer(_, value) {\n  return isObject(value)\n    ? Object.assign(\n        {},\n        ...Object.keys(value)\n          .sort()\n          .map(key => ({\n            [key]: value[key],\n          }))\n      )\n    : value\n}\n\nexport function stableStringify(obj) {\n  return JSON.stringify(obj, stableStringifyReplacer)\n}\n\nexport function isObject(a) {\n  return a && typeof a === 'object' && !Array.isArray(a)\n}\n\nexport function deepIncludes(a, b) {\n  if (a === b) {\n    return true\n  }\n\n  if (typeof a !== typeof b) {\n    return false\n  }\n\n  if (typeof a === 'object') {\n    return !Object.keys(b).some(key => !deepIncludes(a[key], b[key]))\n  }\n\n  return false\n}\n\nexport function isDocumentVisible() {\n  return (\n    typeof document === 'undefined' ||\n    document.visibilityState === undefined ||\n    document.visibilityState === 'visible' ||\n    document.visibilityState === 'prerender'\n  )\n}\n\nexport function isOnline() {\n  return navigator.onLine === undefined || navigator.onLine\n}\n\nexport function getQueryArgs(args) {\n  if (isObject(args[0])) {\n    const { queryKey, queryFn, config } = args[0]\n    args = [queryKey, queryFn, config, ...args.slice(1)]\n  } else if (isObject(args[1])) {\n    const [queryKey, config, ...rest] = args\n    args = [queryKey, undefined, config, ...rest]\n  }\n\n  let [queryKey, queryFn, config = {}, ...rest] = args\n\n  queryFn = queryFn || config.queryFn\n\n  return [queryKey, queryFn ? { ...config, queryFn } : config, ...rest]\n}\n\n// This deep-equal is directly based on https://github.com/epoberezkin/fast-deep-equal.\n// The parts for comparing any non-JSON-supported values has been removed\nexport function deepEqual(a, b) {\n  if (a === b) return true\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    var length, i, keys\n    if (Array.isArray(a)) {\n      length = a.length\n      // eslint-disable-next-line eqeqeq\n      if (length != b.length) return false\n      for (i = length; i-- !== 0; ) if (!deepEqual(a[i], b[i])) return false\n      return true\n    }\n\n    if (a.valueOf !== Object.prototype.valueOf)\n      return a.valueOf() === b.valueOf()\n\n    keys = Object.keys(a)\n    length = keys.length\n    if (length !== Object.keys(b).length) return false\n\n    for (i = length; i-- !== 0; )\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false\n\n    for (i = length; i-- !== 0; ) {\n      var key = keys[i]\n\n      if (!deepEqual(a[key], b[key])) return false\n    }\n\n    return true\n  }\n\n  // true if both NaN, false otherwise\n  // eslint-disable-next-line no-self-compare\n  return a !== a && b !== b\n}\n\nexport function getStatusBools(status) {\n  return {\n    isLoading: status === statusLoading,\n    isSuccess: status === statusSuccess,\n    isError: status === statusError,\n    isIdle: status === statusIdle,\n  }\n}\n","import { noop, stableStringify, identity, deepEqual } from './utils'\n\nexport const DEFAULT_CONFIG = {\n  shared: {\n    suspense: false,\n  },\n  queries: {\n    queryKeySerializerFn: defaultQueryKeySerializerFn,\n    queryFn: undefined,\n    initialStale: undefined,\n    enabled: true,\n    retry: 3,\n    retryDelay: attemptIndex => Math.min(1000 * 2 ** attemptIndex, 30000),\n    staleTime: 0,\n    cacheTime: 5 * 60 * 1000,\n    refetchOnWindowFocus: true,\n    refetchInterval: false,\n    queryFnParamsFilter: identity,\n    refetchOnMount: true,\n    isDataEqual: deepEqual,\n    onError: noop,\n    onSuccess: noop,\n    onSettled: noop,\n    useErrorBoundary: false,\n  },\n  mutations: {\n    throwOnError: false,\n    onMutate: noop,\n    onError: noop,\n    onSuccess: noop,\n    onSettled: noop,\n    useErrorBoundary: false,\n  },\n}\n\nexport const defaultConfigRef = {\n  current: DEFAULT_CONFIG,\n}\n\nexport function defaultQueryKeySerializerFn(queryKey) {\n  if (!queryKey) {\n    return []\n  }\n\n  if (!Array.isArray(queryKey)) {\n    queryKey = [queryKey]\n  }\n\n  if (queryKey.some(d => typeof d === 'function')) {\n    throw new Error('A valid query key is required!')\n  }\n\n  const queryHash = stableStringify(queryKey)\n  queryKey = JSON.parse(queryHash)\n\n  if (!queryHash) {\n    return []\n  }\n\n  return [queryHash, queryKey]\n}\n","import { uid, isServer, isDocumentVisible, Console } from './utils'\n\nexport function makeQueryInstance(query, onStateUpdate) {\n  const instance = {\n    id: uid(),\n    onStateUpdate,\n  }\n\n  instance.clearInterval = () => {\n    clearInterval(instance.refetchIntervalId)\n    delete instance.refetchIntervalId\n  }\n\n  instance.updateConfig = config => {\n    const oldConfig = instance.config\n\n    // Update the config\n    instance.config = config\n\n    if (!isServer) {\n      if (oldConfig?.refetchInterval === config.refetchInterval) {\n        return\n      }\n\n      query.clearIntervals()\n\n      const minInterval = Math.min(\n        ...query.instances.map(d => d.config.refetchInterval || Infinity)\n      )\n\n      if (\n        !instance.refetchIntervalId &&\n        minInterval > 0 &&\n        minInterval < Infinity\n      ) {\n        instance.refetchIntervalId = setInterval(() => {\n          if (\n            query.instances.some(instance => instance.config.enabled) &&\n            (isDocumentVisible() ||\n              query.instances.some(\n                instance => instance.config.refetchIntervalInBackground\n              ))\n          ) {\n            query.fetch()\n          }\n        }, minInterval)\n      }\n    }\n  }\n\n  instance.run = async () => {\n    try {\n      // Perform the refetch for this query if necessary\n      if (\n        query.config.enabled && // Don't auto refetch if disabled\n        !query.wasSuspended && // Don't double refetch for suspense\n        query.state.isStale && // Only refetch if stale\n        (query.config.refetchOnMount || query.instances.length === 1)\n      ) {\n        await query.fetch()\n      }\n\n      query.wasSuspended = false\n    } catch (error) {\n      Console.error(error)\n    }\n  }\n\n  instance.unsubscribe = () => {\n    query.instances = query.instances.filter(d => d.id !== instance.id)\n\n    if (!query.instances.length) {\n      instance.clearInterval()\n      query.cancel()\n\n      if (!isServer) {\n        // Schedule garbage collection\n        query.scheduleGarbageCollection()\n      }\n    }\n  }\n\n  return instance\n}\n","import {\n  isServer,\n  functionalUpdate,\n  cancelledError,\n  isDocumentVisible,\n  statusLoading,\n  statusSuccess,\n  statusError,\n  noop,\n  statusIdle,\n  Console,\n  getStatusBools,\n} from './utils'\nimport { makeQueryInstance } from './queryInstance'\n\nconst actionInit = 'Init'\nconst actionFailed = 'Failed'\nconst actionMarkStale = 'MarkStale'\nconst actionMarkGC = 'MarkGC'\nconst actionFetch = 'Fetch'\nconst actionSuccess = 'Success'\nconst actionError = 'Error'\nconst actionSetState = 'SetState'\n\nexport function makeQuery({\n  queryCache,\n  queryKey,\n  queryHash,\n  config,\n  notifyGlobalListeners,\n}) {\n  const initialData =\n    typeof config.initialData === 'function'\n      ? config.initialData()\n      : config.initialData\n\n  const hasInitialData = typeof initialData !== 'undefined'\n\n  const isStale =\n    !config.enabled ||\n    (typeof config.initialStale === 'function'\n      ? config.initialStale()\n      : config.initialStale ?? !hasInitialData)\n\n  const initialStatus = hasInitialData\n    ? statusSuccess\n    : config.enabled\n    ? statusLoading\n    : statusIdle\n\n  let query = {\n    queryKey,\n    queryHash,\n    config,\n    instances: [],\n    state: queryReducer(undefined, {\n      type: actionInit,\n      initialStatus,\n      initialData,\n      hasInitialData,\n      isStale,\n    }),\n  }\n\n  query.dispatch = action => {\n    query.state = queryReducer(query.state, action)\n    query.instances.forEach(d => d.onStateUpdate(query.state))\n    notifyGlobalListeners()\n  }\n\n  query.scheduleStaleTimeout = () => {\n    if (isServer) return\n    clearTimeout(query.staleTimeout)\n\n    if (query.config.staleTime === Infinity) {\n      return\n    }\n\n    query.staleTimeout = setTimeout(() => {\n      if (queryCache.getQuery(query.queryKey)) {\n        query.invalidate()\n      }\n    }, query.config.staleTime)\n  }\n\n  query.invalidate = () => {\n    clearTimeout(query.staleTimeout)\n    query.dispatch({ type: actionMarkStale })\n  }\n\n  query.scheduleGarbageCollection = () => {\n    if (!queryCache.queries[query.queryHash]) return\n    if (query.config.cacheTime === Infinity) {\n      return\n    }\n    query.dispatch({ type: actionMarkGC })\n    query.cacheTimeout = setTimeout(\n      () => {\n        queryCache.removeQueries(\n          d =>\n            d.state.markedForGarbageCollection &&\n            d.queryHash === query.queryHash\n        )\n      },\n      typeof query.state.data === 'undefined' && query.state.status !== 'error'\n        ? 0\n        : query.config.cacheTime\n    )\n  }\n\n  query.refetch = async () => {\n    try {\n      await query.fetch()\n    } catch (error) {\n      Console.error(error)\n    }\n  }\n\n  query.heal = () => {\n    // Stop the query from being garbage collected\n    clearTimeout(query.cacheTimeout)\n\n    // Mark the query as not cancelled\n    query.cancelled = null\n  }\n\n  query.cancel = () => {\n    query.cancelled = cancelledError\n\n    if (query.cancelPromises) {\n      query.cancelPromises()\n    }\n\n    delete query.promise\n  }\n\n  query.clearIntervals = () => {\n    query.instances.forEach(instance => {\n      instance.clearInterval()\n    })\n  }\n\n  query.setState = updater => query.dispatch({ type: actionSetState, updater })\n\n  query.setData = updater => {\n    // Set data and mark it as cached\n    query.dispatch({ type: actionSuccess, updater })\n\n    // Schedule a fresh invalidation!\n    query.scheduleStaleTimeout()\n  }\n\n  query.clear = () => {\n    clearTimeout(query.staleTimeout)\n    clearTimeout(query.cacheTimeout)\n    clearTimeout(query.retryTimeout)\n    query.clearIntervals()\n    query.cancel()\n    query.dispatch = noop\n    delete queryCache.queries[query.queryHash]\n    notifyGlobalListeners()\n  }\n\n  query.subscribe = (onStateUpdate = noop) => {\n    const instance = makeQueryInstance(query, onStateUpdate)\n    query.instances.push(instance)\n    query.heal()\n    return instance\n  }\n\n  // Set up the core fetcher function\n  const tryFetchData = async (fn, ...args) => {\n    try {\n      // Perform the query\n      const promise = fn(...query.config.queryFnParamsFilter(args))\n\n      query.cancelPromises = () => promise.cancel?.()\n\n      const data = await promise\n      delete query.shouldContinueRetryOnFocus\n\n      delete query.cancelPromises\n      if (query.cancelled) throw query.cancelled\n\n      return data\n    } catch (error) {\n      delete query.cancelPromises\n      if (query.cancelled) throw query.cancelled\n\n      // If we fail, increase the failureCount\n      query.dispatch({ type: actionFailed })\n\n      // Do we need to retry the request?\n      if (\n        query.config.retry === true ||\n        query.state.failureCount <= query.config.retry ||\n        (typeof query.config.retry === 'function' &&\n          query.config.retry(query.state.failureCount, error))\n      ) {\n        // Only retry if the document is visible\n        if (!isDocumentVisible()) {\n          // set this flag to continue retries on focus\n          query.shouldContinueRetryOnFocus = true\n          // Resolve a\n          return new Promise(noop)\n        }\n\n        delete query.shouldContinueRetryOnFocus\n\n        // Determine the retryDelay\n        const delay = functionalUpdate(\n          query.config.retryDelay,\n          query.state.failureCount\n        )\n\n        // Return a new promise with the retry\n        return await new Promise((resolve, reject) => {\n          // Keep track of the retry timeout\n          query.retryTimeout = setTimeout(async () => {\n            if (query.cancelled) return reject(query.cancelled)\n\n            try {\n              const data = await tryFetchData(fn, ...args)\n              if (query.cancelled) return reject(query.cancelled)\n              resolve(data)\n            } catch (error) {\n              if (query.cancelled) return reject(query.cancelled)\n              reject(error)\n            }\n          }, delay)\n        })\n      }\n\n      throw error\n    }\n  }\n\n  query.fetch = async ({ fetchMore } = {}) => {\n    let queryFn = query.config.queryFn\n\n    if (!queryFn) {\n      return\n    }\n\n    if (query.config.infinite) {\n      const originalQueryFn = queryFn\n\n      queryFn = async () => {\n        const data = []\n        const pageVariables = [...query.pageVariables]\n        const rebuiltPageVariables = []\n\n        do {\n          const args = pageVariables.shift()\n\n          if (!data.length) {\n            // the first page query doesn't need to be rebuilt\n            data.push(await originalQueryFn(...args))\n            rebuiltPageVariables.push(args)\n          } else {\n            // get an up-to-date cursor based on the previous data set\n\n            const nextCursor = query.config.getFetchMore(\n              data[data.length - 1],\n              data\n            )\n\n            // break early if there's no next cursor\n            // otherwise we'll start from the beginning\n            // which will cause unwanted duplication\n            if (!nextCursor) {\n              break\n            }\n\n            const pageArgs = [\n              // remove the last argument (the previously saved cursor)\n              ...args.slice(0, -1),\n              nextCursor,\n            ]\n\n            data.push(await originalQueryFn(...pageArgs))\n            rebuiltPageVariables.push(pageArgs)\n          }\n        } while (pageVariables.length)\n\n        query.state.canFetchMore = query.config.getFetchMore(\n          data[data.length - 1],\n          data\n        )\n        query.pageVariables = rebuiltPageVariables\n\n        return data\n      }\n\n      if (fetchMore) {\n        queryFn = async (...args) => {\n          const { fetchMoreInfo, previous } = fetchMore\n          try {\n            query.setState(old => ({\n              ...old,\n              isFetchingMore: previous ? 'previous' : 'next',\n            }))\n\n            const newArgs = [...args, fetchMoreInfo]\n\n            query.pageVariables[previous ? 'unshift' : 'push'](newArgs)\n\n            const newData = await originalQueryFn(...newArgs)\n\n            const data = previous\n              ? [newData, ...query.state.data]\n              : [...query.state.data, newData]\n\n            query.state.canFetchMore = query.config.getFetchMore(newData, data)\n\n            return data\n          } finally {\n            query.setState(old => ({\n              ...old,\n              isFetchingMore: false,\n            }))\n          }\n        }\n      }\n    }\n\n    // Create a new promise for the query cache if necessary\n    if (!query.promise) {\n      query.promise = (async () => {\n        // If there are any retries pending for this query, kill them\n        query.cancelled = null\n\n        const getCallbackInstances = () => {\n          const callbackInstances = [...query.instances]\n\n          if (query.wasSuspended) {\n            callbackInstances.unshift(query.fallbackInstance)\n          }\n          return callbackInstances\n        }\n\n        try {\n          // Set up the query refreshing state\n          query.dispatch({ type: actionFetch })\n\n          // Try to get the data\n          let data = await tryFetchData(queryFn, ...query.queryKey)\n\n          query.setData(old =>\n            query.config.isDataEqual(old, data) ? old : data\n          )\n\n          getCallbackInstances().forEach(\n            instance =>\n              instance.config.onSuccess &&\n              instance.config.onSuccess(query.state.data)\n          )\n\n          getCallbackInstances().forEach(\n            instance =>\n              instance.config.onSettled &&\n              instance.config.onSettled(query.state.data, null)\n          )\n\n          delete query.promise\n\n          return data\n        } catch (error) {\n          query.dispatch({\n            type: actionError,\n            cancelled: error === query.cancelled,\n            error,\n          })\n\n          delete query.promise\n\n          if (error !== query.cancelled) {\n            getCallbackInstances().forEach(\n              instance =>\n                instance.config.onError && instance.config.onError(error)\n            )\n\n            getCallbackInstances().forEach(\n              instance =>\n                instance.config.onSettled &&\n                instance.config.onSettled(undefined, error)\n            )\n\n            throw error\n          }\n        }\n      })()\n    }\n\n    return query.promise\n  }\n\n  if (query.config.infinite) {\n    query.fetchMore = (\n      fetchMoreInfo = query.state.canFetchMore,\n      { previous = false } = {}\n    ) => query.fetch({ fetchMore: { fetchMoreInfo, previous } })\n  }\n\n  return query\n}\n\nexport function queryReducer(state, action) {\n  const newState = switchActions(state, action)\n\n  return Object.assign(newState, getStatusBools(newState.status))\n}\n\nfunction switchActions(state, action) {\n  switch (action.type) {\n    case actionInit:\n      return {\n        status: action.initialStatus,\n        error: null,\n        isFetching: action.initialStatus === 'loading',\n        failureCount: 0,\n        isStale: action.isStale,\n        markedForGarbageCollection: false,\n        data: action.initialData,\n        updatedAt: action.hasInitialData ? Date.now() : 0,\n      }\n    case actionFailed:\n      return {\n        ...state,\n        failureCount: state.failureCount + 1,\n      }\n    case actionMarkStale:\n      return {\n        ...state,\n        isStale: true,\n      }\n    case actionMarkGC: {\n      return {\n        ...state,\n        markedForGarbageCollection: true,\n      }\n    }\n    case actionFetch:\n      return {\n        ...state,\n        status:\n          typeof state.data !== 'undefined' ? statusSuccess : statusLoading,\n        isFetching: true,\n        failureCount: 0,\n      }\n    case actionSuccess:\n      return {\n        ...state,\n        status: statusSuccess,\n        data: functionalUpdate(action.updater, state.data),\n        error: null,\n        isStale: false,\n        isFetching: false,\n        updatedAt: Date.now(),\n        failureCount: 0,\n      }\n    case actionError:\n      return {\n        ...state,\n        isFetching: false,\n        isStale: true,\n        ...(!action.cancelled && {\n          status: statusError,\n          error: action.error,\n          throwInErrorBoundary: true,\n        }),\n      }\n    case actionSetState:\n      return functionalUpdate(action.updater, state)\n    default:\n      throw new Error()\n  }\n}\n","import {\n  isServer,\n  getQueryArgs,\n  deepIncludes,\n  Console,\n  isObject,\n} from './utils'\nimport { defaultConfigRef } from './config'\nimport { makeQuery } from './query'\n\nexport const queryCache = makeQueryCache()\n\nexport const queryCaches = [queryCache]\n\nexport function makeQueryCache({ frozen = isServer, defaultConfig } = {}) {\n  // A frozen cache does not add new queries to the cache\n  const globalListeners = []\n\n  const configRef = defaultConfig\n    ? { current: { ...defaultConfigRef.current, ...defaultConfig }}\n    : defaultConfigRef\n\n  const queryCache = {\n    queries: {},\n    isFetching: 0,\n  }\n\n  const notifyGlobalListeners = () => {\n    queryCache.isFetching = Object.values(queryCache.queries).reduce(\n      (acc, query) => (query.state.isFetching ? acc + 1 : acc),\n      0\n    )\n\n    globalListeners.forEach(d => d(queryCache))\n  }\n\n  queryCache.subscribe = cb => {\n    globalListeners.push(cb)\n    return () => {\n      globalListeners.splice(globalListeners.indexOf(cb), 1)\n    }\n  }\n\n  queryCache.clear = ({ notify = true } = {}) => {\n    Object.values(queryCache.queries).forEach(query => query.clear())\n    queryCache.queries = {}\n    if (notify) {\n      notifyGlobalListeners()\n    }\n  }\n\n  queryCache.getQueries = (predicate, { exact } = {}) => {\n    if (predicate === true) {\n      return Object.values(queryCache.queries)\n    }\n\n    if (typeof predicate !== 'function') {\n      const [\n        queryHash,\n        queryKey,\n      ] = configRef.current.queries.queryKeySerializerFn(predicate)\n\n      predicate = d =>\n        exact ? d.queryHash === queryHash : deepIncludes(d.queryKey, queryKey)\n    }\n\n    return Object.values(queryCache.queries).filter(predicate)\n  }\n\n  queryCache.getQuery = queryKey =>\n    queryCache.getQueries(queryKey, { exact: true })[0]\n\n  queryCache.getQueryData = queryKey =>\n    queryCache.getQuery(queryKey)?.state.data\n\n  queryCache.removeQueries = (...args) => {\n    queryCache.getQueries(...args).forEach(query => query.clear())\n  }\n\n  queryCache.cancelQueries = (...args) => {\n    queryCache.getQueries(...args).forEach(query => query.cancel())\n  }\n\n  queryCache.invalidateQueries = async (\n    predicate,\n    { refetchActive = true, refetchInactive = false, exact, throwOnError } = {}\n  ) => {\n    try {\n      return await Promise.all(\n        queryCache.getQueries(predicate, { exact }).map(query => {\n          if (query.instances.length) {\n            if (\n              refetchActive &&\n              query.instances.some(instance => instance.config.enabled)\n            ) {\n              return query.fetch()\n            }\n          } else {\n            if (refetchInactive) {\n              return query.fetch()\n            }\n          }\n\n          return query.invalidate()\n        })\n      )\n    } catch (err) {\n      if (throwOnError) {\n        throw err\n      }\n    }\n  }\n\n  queryCache.resetErrorBoundaries = () => {\n    queryCache.getQueries(true).forEach(query => {\n      query.state.throwInErrorBoundary = false\n    })\n  }\n\n  queryCache.buildQuery = (userQueryKey, config = {}) => {\n    config = {\n      ...configRef.current.shared,\n      ...configRef.current.queries,\n      ...config,\n    }\n\n    let [queryHash, queryKey] = config.queryKeySerializerFn(userQueryKey)\n\n    let query = queryCache.queries[queryHash]\n\n    if (query) {\n      Object.assign(query, { config })\n    } else {\n      query = makeQuery({\n        queryCache,\n        queryKey,\n        queryHash,\n        config,\n        notifyGlobalListeners,\n      })\n\n      if (config.infinite) {\n        if (\n          typeof query.state.canFetchMore === 'undefined' &&\n          typeof query.state.data !== 'undefined'\n        ) {\n          query.state.canFetchMore = config.getFetchMore(\n            query.state.data[query.state.data.length - 1],\n            query.state.data\n          )\n        }\n\n        // Here we seed the pageVariabes for the query\n        if (!query.pageVariables) {\n          query.pageVariables = [[...query.queryKey]]\n        }\n      }\n\n      // If the query started with data, schedule\n      // a stale timeout\n      if (!isServer && query.state.data) {\n        query.scheduleStaleTimeout()\n\n        // Simulate a query healing process\n        query.heal()\n        // Schedule for garbage collection in case\n        // nothing subscribes to this query\n        query.scheduleGarbageCollection()\n      }\n\n      if (!frozen) {\n        queryCache.queries[queryHash] = query\n\n        if (isServer) {\n          notifyGlobalListeners()\n        } else {\n          // Here, we setTimeout so as to not trigger\n          // any setState's in parent components in the\n          // middle of the render phase.\n          setTimeout(() => {\n            notifyGlobalListeners()\n          })\n        }\n      }\n    }\n\n    query.fallbackInstance = {\n      config: {\n        onSuccess: query.config.onSuccess,\n        onError: query.config.onError,\n        onSettled: query.config.onSettled,\n      },\n    }\n\n    return query\n  }\n\n  queryCache.prefetchQuery = async (...args) => {\n    if (\n      isObject(args[1]) &&\n      (args[1].hasOwnProperty('throwOnError') ||\n        args[1].hasOwnProperty('force'))\n    ) {\n      args[3] = args[1]\n      args[1] = undefined\n      args[2] = undefined\n    }\n\n    let [queryKey, config, { force, throwOnError } = {}] = getQueryArgs(args)\n\n    try {\n      const query = queryCache.buildQuery(queryKey, config)\n      if (force || query.state.isStale) {\n        await query.fetch()\n      }\n      return query.state.data\n    } catch (err) {\n      if (throwOnError) {\n        throw err\n      }\n      Console.error(err)\n    }\n  }\n\n  queryCache.setQueryData = (queryKey, updater, config = {}) => {\n    let query = queryCache.getQuery(queryKey)\n\n    if (!query) {\n      query = queryCache.buildQuery(queryKey, config)\n    }\n\n    query.setData(updater)\n  }\n\n  return queryCache\n}\n","import { isOnline, isDocumentVisible, Console, isServer } from './utils'\nimport { queryCaches } from './queryCache'\n\nconst visibilityChangeEvent = 'visibilitychange'\nconst focusEvent = 'focus'\n\nconst onWindowFocus = () => {\n  if (isDocumentVisible() && isOnline()) {\n    queryCaches.forEach(queryCache =>\n      queryCache\n        .invalidateQueries(query => {\n          if (!query.instances.length) {\n            return false\n          }\n\n          if (!query.instances.some(instance => instance.config.enabled)) {\n            return false\n          }\n\n          if (!query.state.isStale) {\n            return false\n          }\n\n          if (query.shouldContinueRetryOnFocus) {\n            // delete promise, so refetching will create new one\n            delete query.promise\n          }\n\n          return query.config.refetchOnWindowFocus\n        })\n        .catch(Console.error)\n    )\n  }\n}\n\nlet removePreviousHandler\n\nexport function setFocusHandler(callback) {\n  // Unsub the old watcher\n  if (removePreviousHandler) {\n    removePreviousHandler()\n  }\n  // Sub the new watcher\n  removePreviousHandler = callback(onWindowFocus)\n}\n\nsetFocusHandler(handleFocus => {\n  // Listen to visibillitychange and focus\n  if (!isServer && window?.addEventListener) {\n    window.addEventListener(visibilityChangeEvent, handleFocus, false)\n    window.addEventListener(focusEvent, handleFocus, false)\n\n    return () => {\n      // Be sure to unsubscribe if a new handler is set\n      window.removeEventListener(visibilityChangeEvent, handleFocus)\n      window.removeEventListener(focusEvent, handleFocus)\n    }\n  }\n})\n","import React from 'react'\nimport { queryCache, makeQueryCache } from '../core'\n\nexport const queryCacheContext = React.createContext(queryCache)\n\nexport const queryCaches = [queryCache]\n\nexport const useQueryCache = () => React.useContext(queryCacheContext)\n\nexport function ReactQueryCacheProvider({ queryCache, children }) {\n  const resolvedQueryCache = React.useMemo(\n    () => queryCache || makeQueryCache(),\n    [queryCache]\n  )\n\n  React.useEffect(() => {\n    queryCaches.push(resolvedQueryCache)\n\n    return () => {\n      // remove the cache from the active list\n      const i = queryCaches.indexOf(resolvedQueryCache)\n      if (i > -1) {\n        queryCaches.splice(i, 1)\n      }\n      // if the resolvedQueryCache was created by us, we need to tear it down\n      if (queryCache == null) {\n        resolvedQueryCache.clear({ notify: false })\n      }\n    }\n  }, [resolvedQueryCache, queryCache])\n\n  return (\n    <queryCacheContext.Provider value={resolvedQueryCache}>\n      {children}\n    </queryCacheContext.Provider>\n  )\n}\n","import React from 'react'\nimport { DEFAULT_CONFIG, defaultConfigRef } from '../core/config'\n\n//\n\nconst configContext = React.createContext()\n\nexport function useConfigContext() {\n  return React.useContext(configContext) || defaultConfigRef.current\n}\n\nexport function ReactQueryConfigProvider({ config, children }) {\n  let configContextValue = useConfigContext()\n\n  const newConfig = React.useMemo(() => {\n    const { shared = {}, queries = {}, mutations = {} } = config\n    const {\n      shared: contextShared = {},\n      queries: contextQueries = {},\n      mutations: contextMutations = {},\n    } = configContextValue\n\n    return {\n      shared: {\n        ...contextShared,\n        ...shared,\n      },\n      queries: {\n        ...contextQueries,\n        ...queries,\n      },\n      mutations: {\n        ...contextMutations,\n        ...mutations,\n      },\n    }\n  }, [config, configContextValue])\n\n  React.useEffect(() => {\n    // restore previous config on unmount\n    return () => {\n      defaultConfigRef.current = { ...(configContextValue || DEFAULT_CONFIG) }\n    }\n  }, [configContextValue])\n\n  if (!configContextValue) {\n    defaultConfigRef.current = newConfig\n  }\n\n  return (\n    <configContext.Provider value={newConfig}>\n      {children}\n    </configContext.Provider>\n  )\n}\n","import React from 'react'\n\nimport { useConfigContext } from './ReactQueryConfigProvider'\n\nimport {\n  uid,\n  isServer,\n  statusError,\n  statusSuccess,\n  getQueryArgs,\n} from '../core/utils'\n\nexport function useUid() {\n  const ref = React.useRef(null)\n\n  if (ref.current === null) {\n    ref.current = uid()\n  }\n\n  return ref.current\n}\n\nexport function useGetLatest(obj) {\n  const ref = React.useRef()\n  ref.current = obj\n\n  return React.useCallback(() => ref.current, [])\n}\n\nexport function useQueryArgs(args) {\n  const configContext = useConfigContext()\n\n  let [queryKey, config, ...rest] = getQueryArgs(args)\n\n  // Build the final config\n  config = {\n    ...configContext.shared,\n    ...configContext.queries,\n    ...config,\n  }\n\n  return [queryKey, config, ...rest]\n}\n\nexport function useMountedCallback(callback) {\n  const mounted = React.useRef(false)\n\n  React[isServer ? 'useEffect' : 'useLayoutEffect'](() => {\n    mounted.current = true\n    return () => (mounted.current = false)\n  }, [])\n\n  return React.useCallback(\n    (...args) => (mounted.current ? callback(...args) : void 0),\n    [callback]\n  )\n}\n\nexport function handleSuspense(queryInfo) {\n  if (\n    queryInfo.query.config.suspense ||\n    queryInfo.query.config.useErrorBoundary\n  ) {\n    if (\n      queryInfo.query.state.status === statusError &&\n      queryInfo.query.state.throwInErrorBoundary\n    ) {\n      throw queryInfo.error\n    }\n\n    if (\n      queryInfo.query.config.suspense &&\n      queryInfo.status !== statusSuccess &&\n      queryInfo.query.config.enabled\n    ) {\n      queryInfo.query.wasSuspended = true\n      throw queryInfo.query.fetch()\n    }\n  }\n}\n","import React from 'react'\n\nimport { useMountedCallback, useGetLatest } from './utils'\nimport { useQueryCache } from './ReactQueryCacheProvider'\n\nexport function useIsFetching() {\n  const queryCache = useQueryCache()\n  const [state, unsafeRerender] = React.useReducer(d => d + 1, 1)\n  const rerender = useMountedCallback(unsafeRerender)\n\n  const isFetching = React.useMemo(() => state && queryCache.isFetching, [\n    queryCache.isFetching,\n    state,\n  ])\n\n  const getIsFetching = useGetLatest(isFetching)\n\n  React.useEffect(\n    () =>\n      queryCache.subscribe(newCache => {\n        if (getIsFetching() !== newCache.isFetching) rerender()\n      }),\n    [getIsFetching, queryCache, rerender]\n  )\n\n  return isFetching\n}\n","import React from 'react'\n\n//\n\nimport { useConfigContext } from './ReactQueryConfigProvider'\nimport { useGetLatest, useMountedCallback } from './utils'\nimport {\n  statusIdle,\n  statusLoading,\n  statusSuccess,\n  statusError,\n  Console,\n  uid,\n  noop,\n} from '../core/utils'\n\nconst getDefaultState = () => ({\n  status: statusIdle,\n  data: undefined,\n  error: null,\n})\n\nconst actionReset = {}\nconst actionLoading = {}\nconst actionResolve = {}\nconst actionReject = {}\n\nfunction mutationReducer(state, action) {\n  if (action.type === actionReset) {\n    return getDefaultState()\n  }\n  if (action.type === actionLoading) {\n    return {\n      status: statusLoading,\n    }\n  }\n  if (action.type === actionResolve) {\n    return {\n      status: statusSuccess,\n      data: action.data,\n    }\n  }\n  if (action.type === actionReject) {\n    return {\n      status: statusError,\n      error: action.error,\n    }\n  }\n  throw new Error()\n}\n\nexport function useMutation(mutationFn, config = {}) {\n  const [state, unsafeDispatch] = React.useReducer(\n    mutationReducer,\n    null,\n    getDefaultState\n  )\n\n  const dispatch = useMountedCallback(unsafeDispatch)\n\n  const getMutationFn = useGetLatest(mutationFn)\n\n  const getConfig = useGetLatest({\n    ...useConfigContext().shared,\n    ...useConfigContext().mutations,\n    ...config,\n  })\n\n  const latestMutationRef = React.useRef()\n\n  const mutate = React.useCallback(\n    async (\n      variables,\n      { onSuccess = noop, onError = noop, onSettled = noop, throwOnError } = {}\n    ) => {\n      const config = getConfig()\n\n      const mutationId = uid()\n      latestMutationRef.current = mutationId\n\n      const isLatest = () => latestMutationRef.current === mutationId\n\n      let snapshotValue\n\n      try {\n        dispatch({ type: actionLoading })\n        snapshotValue = await config.onMutate(variables)\n\n        let data = await getMutationFn()(variables)\n\n        if (isLatest()) {\n          dispatch({ type: actionResolve, data })\n        }\n\n        await config.onSuccess(data, variables)\n        await onSuccess(data, variables)\n        await config.onSettled(data, null, variables)\n        await onSettled(data, null, variables)\n\n        return data\n      } catch (error) {\n        Console.error(error)\n        await config.onError(error, variables, snapshotValue)\n        await onError(error, variables, snapshotValue)\n        await config.onSettled(undefined, error, variables, snapshotValue)\n        await onSettled(undefined, error, variables, snapshotValue)\n\n        if (isLatest()) {\n          dispatch({ type: actionReject, error })\n        }\n\n        if (throwOnError ?? config.throwOnError) {\n          throw error\n        }\n      }\n    },\n    [dispatch, getConfig, getMutationFn]\n  )\n\n  const reset = React.useCallback(() => dispatch({ type: actionReset }), [\n    dispatch,\n  ])\n\n  React.useEffect(() => {\n    const { suspense, useErrorBoundary } = getConfig()\n\n    if ((useErrorBoundary ?? suspense) && state.error) {\n      throw state.error\n    }\n  }, [getConfig, state.error])\n\n  return [\n    mutate,\n    {\n      ...state,\n      reset,\n      isIdle: state.status === statusIdle,\n      isLoading: state.status === statusLoading,\n      isSuccess: state.status === statusSuccess,\n      isError: state.status === statusError,\n    },\n  ]\n}\n","import React from 'react'\n\n//\n\nimport { useQueryCache } from './ReactQueryCacheProvider'\nimport { useMountedCallback } from './utils'\n\nexport function useBaseQuery(queryKey, config = {}) {\n  // Make a rerender function\n  const rerender = useMountedCallback(React.useState()[1])\n\n  // Get the query cache\n  const queryCache = useQueryCache()\n\n  // Build the query for use\n  const query = queryCache.buildQuery(queryKey, config)\n\n  // Create a query instance ref\n  const instanceRef = React.useRef()\n\n  // Subscribe to the query when the subscribe function changes\n  React.useEffect(() => {\n    instanceRef.current = query.subscribe(() => rerender({}))\n\n    // Unsubscribe when things change\n    return instanceRef.current.unsubscribe\n  }, [query, rerender])\n\n  // Always update the config\n  React.useEffect(() => {\n    instanceRef.current.updateConfig(config)\n  })\n\n  const enabledBool = Boolean(config.enabled)\n\n  // Run the instance when the query or enabled change\n  React.useEffect(() => {\n    if (enabledBool && query) {\n      // Just for change detection\n    }\n    instanceRef.current.run()\n  }, [enabledBool, query])\n\n  return {\n    ...query,\n    ...query.state,\n    query,\n  }\n}\n","import { useBaseQuery } from './useBaseQuery'\nimport { useQueryArgs, handleSuspense } from './utils'\n\nexport function useQuery(...args) {\n  const query = useBaseQuery(...useQueryArgs(args))\n\n  handleSuspense(query)\n\n  return query\n}\n","import React from 'react'\n\n//\n\nimport { useBaseQuery } from './useBaseQuery'\nimport { useQueryArgs, handleSuspense } from './utils'\nimport { getStatusBools } from '../core/utils'\n\n// A paginated query is more like a \"lag\" query, which means\n// as the query key changes, we keep the results from the\n// last query and use them as placeholder data in the next one\n// We DON'T use it as initial data though. That's important\nexport function usePaginatedQuery(...args) {\n  let [queryKey, config = {}] = useQueryArgs(args)\n\n  // Keep track of the latest data result\n  const lastDataRef = React.useRef()\n\n  // If latestData is there, don't use initialData\n  if (typeof lastDataRef.current !== 'undefined') {\n    delete config.initialData\n  }\n\n  // Make the query as normal\n  const queryInfo = useBaseQuery(queryKey, config)\n\n  // If the query is disabled, get rid of the latest data\n  if (!queryInfo.query.config.enabled) {\n    lastDataRef.current = undefined\n  }\n\n  // Get the real data and status from the query\n  let { data: latestData, status } = queryInfo\n\n  // If the real query succeeds, and there is data in it,\n  // update the latest data\n  React.useEffect(() => {\n    if (status === 'success' && typeof latestData !== 'undefined') {\n      lastDataRef.current = latestData\n    }\n  }, [latestData, status])\n\n  // Resolved data should be either the real data we're waiting on\n  // or the latest placeholder data\n  let resolvedData = latestData\n  if (typeof resolvedData === 'undefined') {\n    resolvedData = lastDataRef.current\n  }\n\n  // If we have any data at all from either, we\n  // need to make sure the status is success, even though\n  // the real query may still be loading\n  if (typeof resolvedData !== 'undefined') {\n    const overrides = { status: 'success', ...getStatusBools('success') }\n    Object.assign(queryInfo.query.state, overrides)\n    Object.assign(queryInfo, overrides)\n  }\n\n  const paginatedQueryInfo = {\n    ...queryInfo,\n    resolvedData,\n    latestData,\n  }\n\n  handleSuspense(paginatedQueryInfo)\n\n  return paginatedQueryInfo\n}\n","//\n\nimport { useBaseQuery } from './useBaseQuery'\nimport { useQueryArgs, handleSuspense } from './utils'\n\nexport function useInfiniteQuery(...args) {\n  let [queryKey, config] = useQueryArgs(args)\n\n  config.infinite = true\n\n  const queryInfo = useBaseQuery(queryKey, config)\n\n  handleSuspense(queryInfo)\n\n  return queryInfo\n}\n"],"names":["statusIdle","statusLoading","statusError","statusSuccess","_uid","uid","cancelledError","isServer","window","noop","Console","console","error","warn","log","setConsole","c","functionalUpdate","updater","old","stableStringifyReplacer","_","value","isObject","Object","assign","keys","sort","map","key","stableStringify","obj","JSON","stringify","a","Array","isArray","deepIncludes","b","some","isDocumentVisible","document","undefined","visibilityState","getQueryArgs","args","queryKey","queryFn","config","slice","rest","getStatusBools","status","isLoading","isSuccess","isError","isIdle","DEFAULT_CONFIG","shared","suspense","queries","queryKeySerializerFn","d","Error","queryHash","parse","initialStale","enabled","retry","retryDelay","attemptIndex","Math","min","staleTime","cacheTime","refetchOnWindowFocus","refetchInterval","queryFnParamsFilter","refetchOnMount","isDataEqual","deepEqual","length","i","valueOf","prototype","hasOwnProperty","call","onError","onSuccess","onSettled","useErrorBoundary","mutations","throwOnError","onMutate","defaultConfigRef","current","makeQueryInstance","query","onStateUpdate","f","instance","id","clearInterval","refetchIntervalId","updateConfig","oldConfig","clearIntervals","minInterval","instances","Infinity","setInterval","refetchIntervalInBackground","fetch","run","then","body","recover","result","e","wasSuspended","state","isStale","direct","Promise","resolve","arguments","apply","this","reject","unsubscribe","filter","cancel","scheduleGarbageCollection","_empty","_catch","_async","_await","_invoke","pact","s","o","_settle","bind","v","observer","_Pact","onFulfilled","onRejected","callback","_this","thenable","thrown","finalizer","makeQuery","queryCache","notifyGlobalListeners","initialData","hasInitialData","queryReducer","type","initialStatus","action","forEach","clearTimeout","staleTimeout","setTimeout","getQuery","invalidate","dispatch","cacheTimeout","removeQueries","markedForGarbageCollection","data","refetch","heal","cancelled","cancelPromises","promise","setState","setData","scheduleStaleTimeout","clear","retryTimeout","subscribe","push","tryFetchData","fn","shouldContinueRetryOnFocus","failureCount","delay","fetchMore","infinite","originalQueryFn","pageVariables","rebuiltPageVariables","test","awaitBody","_isSettledPact","shouldContinue","_resumeAfterBody","_resumeAfterTest","shift","nextCursor","getFetchMore","pageArgs","canFetchMore","fetchMoreInfo","previous","isFetchingMore","newArgs","newData","getCallbackInstances","callbackInstances","unshift","fallbackInstance","newState","isFetching","updatedAt","Date","now","throwInErrorBoundary","switchActions","makeQueryCache","queryCaches","frozen","defaultConfig","globalListeners","configRef","values","reduce","acc","cb","splice","indexOf","notify","getQueries","predicate","exact","getQueryData","_queryCache$getQuery","cancelQueries","invalidateQueries","refetchActive","refetchInactive","all","err","resetErrorBoundaries","buildQuery","userQueryKey","prefetchQuery","force","setQueryData","removePreviousHandler","onWindowFocus","navigator","onLine","catch","setFocusHandler","handleFocus","_window","addEventListener","removeEventListener","queryCacheContext","React","createContext","useQueryCache","useContext","ReactQueryCacheProvider","children","resolvedQueryCache","useMemo","useEffect","Provider","configContext","useConfigContext","ReactQueryConfigProvider","configContextValue","newConfig","contextShared","contextQueries","contextMutations","useGetLatest","ref","useRef","useCallback","useQueryArgs","useMountedCallback","mounted","handleSuspense","queryInfo","useIsFetching","useReducer","rerender","getIsFetching","newCache","getDefaultState","actionReset","actionLoading","actionResolve","actionReject","mutationReducer","useMutation","mutationFn","getMutationFn","getConfig","latestMutationRef","mutate","variables","mutationId","snapshotValue","isLatest","reset","useBaseQuery","useState","instanceRef","enabledBool","Boolean","useQuery","usePaginatedQuery","lastDataRef","latestData","resolvedData","overrides","paginatedQueryInfo","useInfiniteQuery"],"mappings":"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"}