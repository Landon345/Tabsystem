{"ast":null,"code":"import React from 'react';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n} // A type of promise-like that resolves synchronously and supports only one observer\n\n\nconst _Pact = /*#__PURE__*/function () {\n  function _Pact() {}\n\n  _Pact.prototype.then = function (onFulfilled, onRejected) {\n    const result = new _Pact();\n    const state = this.s;\n\n    if (state) {\n      const callback = state & 1 ? onFulfilled : onRejected;\n\n      if (callback) {\n        try {\n          _settle(result, 1, callback(this.v));\n        } catch (e) {\n          _settle(result, 2, e);\n        }\n\n        return result;\n      } else {\n        return this;\n      }\n    }\n\n    this.o = function (_this) {\n      try {\n        const value = _this.v;\n\n        if (_this.s & 1) {\n          _settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n        } else if (onRejected) {\n          _settle(result, 1, onRejected(value));\n        } else {\n          _settle(result, 2, value);\n        }\n      } catch (e) {\n        _settle(result, 2, e);\n      }\n    };\n\n    return result;\n  };\n\n  return _Pact;\n}(); // Settles a pact synchronously\n\n\nfunction _settle(pact, state, value) {\n  if (!pact.s) {\n    if (value instanceof _Pact) {\n      if (value.s) {\n        if (state & 1) {\n          state = value.s;\n        }\n\n        value = value.v;\n      } else {\n        value.o = _settle.bind(null, pact, state);\n        return;\n      }\n    }\n\n    if (value && value.then) {\n      value.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n      return;\n    }\n\n    pact.s = state;\n    pact.v = value;\n    const observer = pact.o;\n\n    if (observer) {\n      observer(pact);\n    }\n  }\n}\n\nfunction _isSettledPact(thenable) {\n  return thenable instanceof _Pact && thenable.s & 1;\n} // Converts argument to a function that always returns a Promise\n\n\nfunction _async(f) {\n  return function () {\n    for (var args = [], i = 0; i < arguments.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    try {\n      return Promise.resolve(f.apply(this, args));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n} // Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\n\n\nfunction _await(value, then, direct) {\n  if (direct) {\n    return then ? then(value) : value;\n  }\n\n  if (!value || !value.then) {\n    value = Promise.resolve(value);\n  }\n\n  return then ? value.then(then) : value;\n} // Awaits on a value that may or may not be a Promise, then ignores it\n\n\nfunction _awaitIgnored(value, direct) {\n  if (!direct) {\n    return value && value.then ? value.then(_empty) : Promise.resolve();\n  }\n} // Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\n\n\nfunction _continue(value, then) {\n  return value && value.then ? value.then(then) : then(value);\n} // Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\n\n\nconst _iteratorSymbol = /*#__PURE__*/typeof Symbol !== \"undefined\" ? Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\")) : \"@@iterator\"; // Asynchronously iterate through an object's values\n\n\nconst _asyncIteratorSymbol = /*#__PURE__*/typeof Symbol !== \"undefined\" ? Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\")) : \"@@asyncIterator\"; // Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\n\n\nfunction _do(body, test) {\n  var awaitBody;\n\n  do {\n    var result = body();\n\n    if (result && result.then) {\n      if (_isSettledPact(result)) {\n        result = result.v;\n      } else {\n        awaitBody = true;\n        break;\n      }\n    }\n\n    var shouldContinue = test();\n\n    if (_isSettledPact(shouldContinue)) {\n      shouldContinue = shouldContinue.v;\n    }\n\n    if (!shouldContinue) {\n      return result;\n    }\n  } while (!shouldContinue.then);\n\n  const pact = new _Pact();\n\n  const reject = _settle.bind(null, pact, 2);\n\n  (awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n  return pact;\n\n  function _resumeAfterBody(value) {\n    result = value;\n\n    for (;;) {\n      shouldContinue = test();\n\n      if (_isSettledPact(shouldContinue)) {\n        shouldContinue = shouldContinue.v;\n      }\n\n      if (!shouldContinue) {\n        break;\n      }\n\n      if (shouldContinue.then) {\n        shouldContinue.then(_resumeAfterTest).then(void 0, reject);\n        return;\n      }\n\n      result = body();\n\n      if (result && result.then) {\n        if (_isSettledPact(result)) {\n          result = result.v;\n        } else {\n          result.then(_resumeAfterBody).then(void 0, reject);\n          return;\n        }\n      }\n    }\n\n    _settle(pact, 1, result);\n  }\n\n  function _resumeAfterTest(shouldContinue) {\n    if (shouldContinue) {\n      do {\n        result = body();\n\n        if (result && result.then) {\n          if (_isSettledPact(result)) {\n            result = result.v;\n          } else {\n            result.then(_resumeAfterBody).then(void 0, reject);\n            return;\n          }\n        }\n\n        shouldContinue = test();\n\n        if (_isSettledPact(shouldContinue)) {\n          shouldContinue = shouldContinue.v;\n        }\n\n        if (!shouldContinue) {\n          _settle(pact, 1, result);\n\n          return;\n        }\n      } while (!shouldContinue.then);\n\n      shouldContinue.then(_resumeAfterTest).then(void 0, reject);\n    } else {\n      _settle(pact, 1, result);\n    }\n  }\n} // Asynchronously implement a switch statement\n\n\nfunction _invoke(body, then) {\n  var result = body();\n\n  if (result && result.then) {\n    return result.then(then);\n  }\n\n  return then(result);\n} // Asynchronously call a function and swallow the result\n\n\nfunction _invokeIgnored(body) {\n  var result = body();\n\n  if (result && result.then) {\n    return result.then(_empty);\n  }\n} // Asynchronously call a function and send errors to recovery continuation\n\n\nfunction _catch(body, recover) {\n  try {\n    var result = body();\n  } catch (e) {\n    return recover(e);\n  }\n\n  if (result && result.then) {\n    return result.then(void 0, recover);\n  }\n\n  return result;\n} // Asynchronously await a promise and pass the result to a finally continuation\n\n\nfunction _finallyRethrows(body, finalizer) {\n  try {\n    var result = body();\n  } catch (e) {\n    return finalizer(true, e);\n  }\n\n  if (result && result.then) {\n    return result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n  }\n\n  return finalizer(false, result);\n} // Asynchronously await a promise and invoke a finally continuation that always overrides the result\n\n\nfunction _rethrow(thrown, value) {\n  if (thrown) throw value;\n  return value;\n} // Empty function to implement break and other control flow that ignores asynchronous results\n\n\nfunction _empty() {} // Sentinel value for early returns in generators\n\n\nvar statusIdle = 'idle';\nvar statusLoading = 'loading';\nvar statusError = 'error';\nvar statusSuccess = 'success';\nvar _uid = 0;\n\nvar uid = function uid() {\n  return _uid++;\n};\n\nvar cancelledError = {};\nvar isServer = typeof window === 'undefined';\n\nvar noop = function noop() {};\n\nvar identity = function identity(d) {\n  return d;\n};\n\nvar Console = console || {\n  error: noop,\n  warn: noop,\n  log: noop\n};\n\nfunction useUid() {\n  var ref = React.useRef(null);\n\n  if (ref.current === null) {\n    ref.current = uid();\n  }\n\n  return ref.current;\n}\n\nfunction setConsole(c) {\n  Console = c;\n}\n\nfunction useGetLatest(obj) {\n  var ref = React.useRef();\n  ref.current = obj;\n  return React.useCallback(function () {\n    return ref.current;\n  }, []);\n}\n\nfunction functionalUpdate(updater, old) {\n  return typeof updater === 'function' ? updater(old) : updater;\n}\n\nfunction stableStringifyReplacer(_, value) {\n  return isObject(value) ? Object.assign.apply(Object, [{}].concat(Object.keys(value).sort().map(function (key) {\n    var _ref;\n\n    return _ref = {}, _ref[key] = value[key], _ref;\n  }))) : value;\n}\n\nfunction stableStringify(obj) {\n  return JSON.stringify(obj, stableStringifyReplacer);\n}\n\nfunction isObject(a) {\n  return a && typeof a === 'object' && !Array.isArray(a);\n}\n\nfunction deepIncludes(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (typeof a !== typeof b) {\n    return false;\n  }\n\n  if (typeof a === 'object') {\n    return !Object.keys(b).some(function (key) {\n      return !deepIncludes(a[key], b[key]);\n    });\n  }\n\n  return false;\n}\n\nfunction isDocumentVisible() {\n  return typeof document === 'undefined' || document.visibilityState === undefined || document.visibilityState === 'visible' || document.visibilityState === 'prerender';\n}\n\nfunction isOnline() {\n  return navigator.onLine === undefined || navigator.onLine;\n}\n\nfunction getQueryArgs(args) {\n  if (isObject(args[0])) {\n    if (args[0].hasOwnProperty('queryKey') && args[0].hasOwnProperty('queryFn')) {\n      var _args$ = args[0],\n          _queryKey = _args$.queryKey,\n          _args$$variables = _args$.variables,\n          variables = _args$$variables === void 0 ? [] : _args$$variables,\n          _queryFn = _args$.queryFn,\n          _args$$config = _args$.config,\n          _config = _args$$config === void 0 ? {} : _args$$config;\n\n      return [_queryKey, variables, _queryFn, _config];\n    } else {\n      throw new Error('queryKey and queryFn keys are required.');\n    }\n  }\n\n  if (typeof args[2] === 'function') {\n    var _queryKey2 = args[0],\n        _args$2 = args[1],\n        _variables = _args$2 === void 0 ? [] : _args$2,\n        _queryFn2 = args[2],\n        _args$3 = args[3],\n        _config2 = _args$3 === void 0 ? {} : _args$3;\n\n    return [_queryKey2, _variables, _queryFn2, _config2];\n  }\n\n  var queryKey = args[0],\n      queryFn = args[1],\n      _args$4 = args[2],\n      config = _args$4 === void 0 ? {} : _args$4;\n  return [queryKey, [], queryFn, config];\n}\n\nfunction useMountedCallback(callback) {\n  var mounted = React.useRef(false);\n  React[isServer ? 'useEffect' : 'useLayoutEffect'](function () {\n    mounted.current = true;\n    return function () {\n      return mounted.current = false;\n    };\n  }, []);\n  return React.useCallback(function () {\n    return mounted.current ? callback.apply(void 0, arguments) : void 0;\n  }, [callback]);\n}\n\nfunction handleSuspense(queryInfo) {\n  if (queryInfo.config.suspense || queryInfo.config.useErrorBoundary) {\n    if (queryInfo.status === statusError) {\n      setTimeout(function () {\n        queryInfo.query.state.status = 'loading';\n      });\n      throw queryInfo.error;\n    }\n  }\n\n  if (queryInfo.config.suspense) {\n    if (queryInfo.status === statusLoading) {\n      queryInfo.query.wasSuspended = true;\n      throw queryInfo.refetch();\n    }\n  }\n} // This deep-equal is directly based on https://github.com/epoberezkin/fast-deep-equal.\n// The parts for comparing any non-JSON-supported values has been removed\n\n\nfunction deepEqual(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    var length, i, keys;\n\n    if (Array.isArray(a)) {\n      length = a.length; // eslint-disable-next-line eqeqeq\n\n      if (length != b.length) return false;\n\n      for (i = length; i-- !== 0;) {\n        if (!deepEqual(a[i], b[i])) return false;\n      }\n\n      return true;\n    }\n\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;) {\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n    }\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n      if (!deepEqual(a[key], b[key])) return false;\n    }\n\n    return true;\n  } // true if both NaN, false otherwise\n  // eslint-disable-next-line no-self-compare\n\n\n  return a !== a && b !== b;\n}\n\nvar configContext = React.createContext();\nvar DEFAULTS = {\n  retry: 3,\n  retryDelay: function retryDelay(attemptIndex) {\n    return Math.min(1000 * Math.pow(2, attemptIndex), 30000);\n  },\n  staleTime: 0,\n  cacheTime: 5 * 60 * 1000,\n  refetchAllOnWindowFocus: true,\n  refetchInterval: false,\n  suspense: false,\n  queryKeySerializerFn: defaultQueryKeySerializerFn,\n  queryFnParamsFilter: identity,\n  throwOnError: false,\n  useErrorBoundary: undefined,\n  // this will default to the suspense value\n  onMutate: noop,\n  onSuccess: noop,\n  onError: noop,\n  onSettled: noop,\n  refetchOnMount: true,\n  isDataEqual: deepEqual\n};\nvar defaultConfigRef = {\n  current: DEFAULTS\n};\n\nfunction useConfigContext() {\n  return React.useContext(configContext) || defaultConfigRef.current;\n}\n\nfunction ReactQueryConfigProvider(_ref) {\n  var config = _ref.config,\n      children = _ref.children;\n  var configContextValue = React.useContext(configContext);\n  var newConfig = React.useMemo(function () {\n    var newConfig = _extends({}, configContextValue || defaultConfigRef.current, {}, config); // Default useErrorBoundary to the suspense value\n\n\n    if (typeof newConfig.useErrorBoundary === 'undefined') {\n      newConfig.useErrorBoundary = newConfig.suspense;\n    }\n\n    return newConfig;\n  }, [config, configContextValue]);\n  React.useEffect(function () {\n    // restore previous config on unmount\n    return function () {\n      defaultConfigRef.current = _extends({}, configContextValue || DEFAULTS); // Default useErrorBoundary to the suspense value\n\n      if (typeof defaultConfigRef.current.useErrorBoundary === 'undefined') {\n        defaultConfigRef.current.useErrorBoundary = defaultConfigRef.current.suspense;\n      }\n    };\n  }, [configContextValue]);\n\n  if (!configContextValue) {\n    defaultConfigRef.current = newConfig;\n  }\n\n  return React.createElement(configContext.Provider, {\n    value: newConfig\n  }, children);\n}\n\nfunction defaultQueryKeySerializerFn(queryKey) {\n  if (!queryKey) {\n    return [];\n  }\n\n  if (typeof queryKey === 'function') {\n    try {\n      return defaultQueryKeySerializerFn(queryKey());\n    } catch (_unused) {\n      return [];\n    }\n  }\n\n  if (typeof queryKey === 'string') {\n    queryKey = [queryKey];\n  }\n\n  var queryHash = stableStringify(queryKey);\n  queryKey = JSON.parse(queryHash);\n  return [queryHash, queryKey];\n}\n\nvar queryCache = makeQueryCache();\nvar queryCacheContext = React.createContext(queryCache);\nvar queryCaches = [queryCache];\n\nfunction useQueryCache() {\n  return React.useContext(queryCacheContext);\n}\n\nfunction ReactQueryCacheProvider(_ref) {\n  var queryCache = _ref.queryCache,\n      children = _ref.children;\n  var cache = React.useMemo(function () {\n    return queryCache || makeQueryCache();\n  }, [queryCache]);\n  React.useEffect(function () {\n    queryCaches.push(cache);\n    return function () {\n      // remove the cache from the active list\n      var i = queryCaches.indexOf(cache);\n\n      if (i >= 0) {\n        queryCaches.splice(i, 1);\n      } // if the cache was created by us, we need to tear it down\n\n\n      if (queryCache == null) {\n        cache.clear();\n      }\n    };\n  }, [cache, queryCache]);\n  return React.createElement(queryCacheContext.Provider, {\n    value: cache\n  }, children);\n}\n\nvar actionInit = {};\nvar actionFailed = {};\nvar actionMarkStale = {};\nvar actionMarkGC = {};\nvar actionFetch = {};\nvar actionSuccess = {};\nvar actionError = {};\nvar actionSetState = {};\n\nfunction makeQueryCache() {\n  var listeners = [];\n  var cache = {\n    queries: {},\n    isFetching: 0\n  };\n\n  var notifyGlobalListeners = function notifyGlobalListeners() {\n    cache.isFetching = Object.values(cache.queries).reduce(function (acc, query) {\n      return query.state.isFetching ? acc + 1 : acc;\n    }, 0);\n    listeners.forEach(function (d) {\n      return d(cache);\n    });\n  };\n\n  cache.subscribe = function (cb) {\n    listeners.push(cb);\n    return function () {\n      listeners.splice(listeners.indexOf(cb), 1);\n    };\n  };\n\n  cache.clear = function () {\n    Object.values(cache.queries).forEach(function (query) {\n      return query.clear();\n    });\n    cache.queries = {};\n    notifyGlobalListeners();\n  };\n\n  var findQueries = function findQueries(predicate, _temp) {\n    var _ref2 = _temp === void 0 ? {} : _temp,\n        exact = _ref2.exact;\n\n    if (typeof predicate !== 'function') {\n      var _defaultConfigRef$cur = defaultConfigRef.current.queryKeySerializerFn(predicate),\n          queryHash = _defaultConfigRef$cur[0],\n          queryKey = _defaultConfigRef$cur[1];\n\n      predicate = function predicate(d) {\n        return exact ? d.queryHash === queryHash : deepIncludes(d.queryKey, queryKey);\n      };\n    }\n\n    return Object.values(cache.queries).filter(predicate);\n  };\n\n  cache.getQueries = findQueries;\n\n  cache.getQuery = function (queryKey) {\n    return findQueries(queryKey, {\n      exact: true\n    })[0];\n  };\n\n  cache.getQueryData = function (queryKey) {\n    var _cache$getQuery;\n\n    return (_cache$getQuery = cache.getQuery(queryKey)) == null ? void 0 : _cache$getQuery.state.data;\n  };\n\n  cache.removeQueries = function (predicate, _temp2) {\n    var _ref3 = _temp2 === void 0 ? {} : _temp2,\n        exact = _ref3.exact;\n\n    var foundQueries = findQueries(predicate, {\n      exact: exact\n    });\n    foundQueries.forEach(function (query) {\n      clearTimeout(query.staleTimeout);\n      delete cache.queries[query.queryHash];\n    });\n\n    if (foundQueries.length) {\n      notifyGlobalListeners();\n    }\n  };\n\n  cache.cancelQueries = function (predicate, _temp3) {\n    var _ref4 = _temp3 === void 0 ? {} : _temp3,\n        exact = _ref4.exact;\n\n    var foundQueries = findQueries(predicate, {\n      exact: exact\n    });\n    foundQueries.forEach(function (query) {\n      query.cancel();\n    });\n\n    if (foundQueries.length) {\n      notifyGlobalListeners();\n    }\n  };\n\n  cache.refetchQueries = _async(function (predicate, _temp4) {\n    var _ref5 = _temp4 === void 0 ? {} : _temp4,\n        exact = _ref5.exact,\n        throwOnError = _ref5.throwOnError,\n        force = _ref5.force;\n\n    var foundQueries = predicate === true ? Object.values(cache.queries) : findQueries(predicate, {\n      exact: exact\n    });\n    return _catch(function () {\n      return _await(Promise.all(foundQueries.map(function (query) {\n        return query.fetch({\n          force: force\n        });\n      })));\n    }, function (err) {\n      if (throwOnError) {\n        throw err;\n      }\n    });\n  });\n\n  cache._buildQuery = function (userQueryKey, queryVariables, queryFn, config) {\n    var _config$queryKeySeria = config.queryKeySerializerFn(userQueryKey),\n        queryHash = _config$queryKeySeria[0],\n        queryKey = _config$queryKeySeria[1];\n\n    var query = cache.queries[queryHash];\n\n    if (query) {\n      Object.assign(query, {\n        queryVariables: queryVariables,\n        queryFn: queryFn\n      });\n      query.config = _extends({}, query.config, {}, config);\n    } else {\n      query = makeQuery({\n        cache: cache,\n        queryKey: queryKey,\n        queryHash: queryHash,\n        queryVariables: queryVariables,\n        queryFn: queryFn,\n        config: config\n      }); // If the query started with data, schedule\n      // a stale timeout\n\n      if (!isServer && query.state.data) {\n        query.scheduleStaleTimeout(); // Simulate a query healing process\n\n        query.heal(); // Schedule for garbage collection in case\n        // nothing subscribes to this query\n\n        query.scheduleGarbageCollection();\n      }\n\n      if (query.queryHash) {\n        if (!isServer) {\n          cache.queries[queryHash] = query; // Here, we setTimeout so as to not trigger\n          // any setState's in parent components in the\n          // middle of the render phase.\n\n          setTimeout(function () {\n            notifyGlobalListeners();\n          });\n        }\n      }\n    }\n\n    return query;\n  };\n\n  cache.prefetchQuery = _async(function () {\n    var _exit = false;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var _getQueryArgs = getQueryArgs(args),\n        queryKey = _getQueryArgs[0],\n        queryVariables = _getQueryArgs[1],\n        queryFn = _getQueryArgs[2],\n        _getQueryArgs$ = _getQueryArgs[3],\n        force = _getQueryArgs$.force,\n        config = _objectWithoutPropertiesLoose(_getQueryArgs$, [\"force\"]);\n\n    config = _extends({}, defaultConfigRef.current, {}, config);\n\n    var query = cache._buildQuery(queryKey, queryVariables, queryFn, config); // Don't prefetch queries that are fresh, unless force is passed\n\n\n    return _invoke(function () {\n      if (query.state.isStale || force) {\n        // Trigger a fetch and return the promise\n        return _catch(function () {\n          return _await(query.fetch({\n            force: force\n          }), function (res) {\n            query.wasPrefetched = true;\n            _exit = true;\n            return res;\n          });\n        }, function (err) {\n          if (config.throwOnError) {\n            throw err;\n          }\n        });\n      }\n    }, function (_result3) {\n      return _exit ? _result3 : query.state.data;\n    });\n  });\n\n  cache.setQueryData = function (queryKey, updater, _ref6) {\n    if (_ref6 === void 0) {\n      _ref6 = {};\n    }\n\n    var _ref7 = _ref6,\n        exact = _ref7.exact,\n        config = _objectWithoutPropertiesLoose(_ref7, [\"exact\"]);\n\n    var queries = findQueries(queryKey, {\n      exact: exact\n    });\n\n    if (!queries.length && typeof queryKey !== 'function') {\n      queries = [cache._buildQuery(queryKey, undefined, function () {\n        return new Promise(noop);\n      }, _extends({}, defaultConfigRef.current, {}, config))];\n    }\n\n    queries.forEach(function (d) {\n      return d.setData(updater);\n    });\n  };\n\n  function makeQuery(options) {\n    var queryCache = options.cache;\n    var reducer = options.config.queryReducer || defaultQueryReducer;\n    var noQueryHash = typeof options.queryHash === 'undefined';\n    var initialData = typeof options.config.initialData === 'function' ? options.config.initialData() : options.config.initialData;\n    var hasInitialData = typeof initialData !== 'undefined';\n    var isStale = noQueryHash ? true : !hasInitialData;\n    var manual = options.config.manual;\n    var initialStatus = noQueryHash || manual || hasInitialData ? statusSuccess : statusLoading;\n\n    var query = _extends({}, options, {\n      instances: [],\n      state: reducer(undefined, {\n        type: actionInit,\n        initialStatus: initialStatus,\n        initialData: initialData,\n        hasInitialData: hasInitialData,\n        isStale: isStale,\n        manual: manual\n      })\n    });\n\n    var dispatch = function dispatch(action) {\n      query.state = reducer(query.state, action);\n      query.instances.forEach(function (d) {\n        return d.onStateUpdate(query.state);\n      });\n      notifyGlobalListeners();\n    };\n\n    query.scheduleStaleTimeout = function () {\n      if (query.config.staleTime === Infinity) {\n        return;\n      }\n\n      query.staleTimeout = setTimeout(function () {\n        if (queryCache.getQuery(query.queryKey)) {\n          dispatch({\n            type: actionMarkStale\n          });\n        }\n      }, query.config.staleTime);\n    };\n\n    query.scheduleGarbageCollection = function () {\n      if (query.config.cacheTime === Infinity) {\n        return;\n      }\n\n      dispatch({\n        type: actionMarkGC\n      });\n      query.cacheTimeout = setTimeout(function () {\n        cache.removeQueries(function (d) {\n          return d.state.markedForGarbageCollection && d.queryHash === query.queryHash;\n        });\n      }, typeof query.state.data === 'undefined' && query.state.status !== 'error' ? 0 : query.config.cacheTime);\n    };\n\n    query.heal = function () {\n      // Stop the query from being garbage collected\n      clearTimeout(query.cacheTimeout); // Mark the query as not cancelled\n\n      query.cancelled = null;\n    };\n\n    query.cancel = function () {\n      query.cancelled = cancelledError;\n\n      if (query.cancelPromises) {\n        query.cancelPromises();\n      }\n\n      delete query.promise;\n      notifyGlobalListeners();\n    };\n\n    query.updateInstance = function (instance) {\n      var found = query.instances.find(function (d) {\n        return d.id === instance.id;\n      });\n\n      if (found) {\n        Object.assign(found, instance);\n      } else {\n        found = _extends({\n          onStateUpdate: noop\n        }, instance);\n        query.instances.push(instance);\n      }\n    };\n\n    query.subscribe = function (instanceId) {\n      query.heal(); // Return the unsubscribe function\n\n      return function () {\n        query.instances = query.instances.filter(function (d) {\n          return d.id !== instanceId;\n        });\n\n        if (!query.instances.length) {\n          query.cancel(); // Schedule garbage collection\n\n          query.scheduleGarbageCollection();\n        }\n      };\n    }; // Set up the fetch function\n\n\n    var tryFetchData = _async(function (queryFn) {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      return _catch(function () {\n        // Perform the query\n        var promise = queryFn.apply(void 0, query.config.queryFnParamsFilter(args));\n\n        query.cancelPromises = function () {\n          return promise.cancel == null ? void 0 : promise.cancel();\n        };\n\n        return _await(promise, function (data) {\n          delete query.shouldContinueRetryOnFocus;\n          delete query.cancelPromises;\n          if (query.cancelled) throw query.cancelled;\n          return data;\n        });\n      }, function (error) {\n        var _exit2 = false;\n        delete query.cancelPromises;\n        if (query.cancelled) throw query.cancelled; // If we fail, increase the failureCount\n\n        dispatch({\n          type: actionFailed\n        }); // Do we need to retry the request?\n\n        return _invoke(function () {\n          if (query.config.retry === true || query.state.failureCount <= query.config.retry || typeof query.config.retry === 'function' && query.config.retry(query.state.failureCount, error)) {\n            // Only retry if the document is visible\n            if (!isDocumentVisible()) {\n              // set this flag to continue fetch retries on focus\n              query.shouldContinueRetryOnFocus = true;\n              _exit2 = true;\n              return new Promise(noop);\n            }\n\n            delete query.shouldContinueRetryOnFocus; // Determine the retryDelay\n\n            var delay = functionalUpdate(query.config.retryDelay, query.state.failureCount); // Return a new promise with the retry\n\n            _exit2 = true;\n            return _await(new Promise(function (resolve, reject) {\n              // Keep track of the retry timeout\n              setTimeout(_async(function () {\n                return query.cancelled ? reject(query.cancelled) : _catch(function () {\n                  return _await(tryFetchData.apply(void 0, [queryFn].concat(args)), function (data) {\n                    if (query.cancelled) return reject(query.cancelled);\n                    resolve(data);\n                  });\n                }, function (error) {\n                  if (query.cancelled) return reject(query.cancelled);\n                  reject(error);\n                });\n              }), delay);\n            }));\n          }\n        }, function (_result4) {\n          if (_exit2) return _result4;\n          throw error;\n        });\n      });\n    });\n\n    query.fetch = _async(function (_temp6) {\n      var _ref8 = _temp6 === void 0 ? {} : _temp6,\n          force = _ref8.force,\n          _ref8$__queryFn = _ref8.__queryFn,\n          __queryFn = _ref8$__queryFn === void 0 ? query.queryFn : _ref8$__queryFn; // Don't refetch fresh queries that don't have a queryHash\n\n\n      if (!query.queryHash || !query.state.isStale && !force) {\n        return;\n      } // Create a new promise for the query cache if necessary\n\n\n      if (!query.promise) {\n        query.promise = _async(function () {\n          // If there are any retries pending for this query, kill them\n          query.cancelled = null;\n          var callbackInstances = [].concat(query.instances);\n\n          if (query.wasSuspended) {\n            callbackInstances.unshift(query.suspenseInstance);\n          }\n\n          return _catch(function () {\n            // Set up the query refreshing state\n            dispatch({\n              type: actionFetch\n            }); // Try to fetch\n\n            return _await(tryFetchData.apply(void 0, [__queryFn].concat(query.queryKey, query.queryVariables)), function (data) {\n              query.setData(function (old) {\n                return query.config.isDataEqual(old, data) ? old : data;\n              });\n              callbackInstances.forEach(function (instance) {\n                return instance.onSuccess && instance.onSuccess(query.state.data);\n              });\n              callbackInstances.forEach(function (instance) {\n                return instance.onSettled && instance.onSettled(query.state.data, null);\n              });\n              delete query.promise;\n              return data;\n            });\n          }, function (error) {\n            dispatch({\n              type: actionError,\n              cancelled: error === query.cancelled,\n              error: error\n            });\n            delete query.promise;\n\n            if (error !== query.cancelled) {\n              callbackInstances.forEach(function (instance) {\n                return instance.onError && instance.onError(error);\n              });\n              callbackInstances.forEach(function (instance) {\n                return instance.onSettled && instance.onSettled(undefined, error);\n              });\n              throw error;\n            }\n          });\n        })();\n      }\n\n      return query.promise;\n    });\n\n    query.setState = function (updater) {\n      return dispatch({\n        type: actionSetState,\n        updater: updater\n      });\n    };\n\n    query.setData = function (updater) {\n      // Set data and mark it as cached\n      dispatch({\n        type: actionSuccess,\n        updater: updater\n      }); // Schedule a fresh invalidation!\n\n      clearTimeout(query.staleTimeout);\n      query.scheduleStaleTimeout();\n    };\n\n    query.clear = function () {\n      clearTimeout(query.staleTimeout);\n      clearTimeout(query.cacheTimeout);\n      query.cancel();\n    };\n\n    return query;\n  }\n\n  return cache;\n}\n\nfunction defaultQueryReducer(state, action) {\n  switch (action.type) {\n    case actionInit:\n      return {\n        status: action.initialStatus,\n        error: null,\n        isFetching: action.hasInitialData || action.manual ? false : action.initialStatus === 'loading',\n        canFetchMore: false,\n        failureCount: 0,\n        isStale: action.isStale,\n        markedForGarbageCollection: false,\n        data: action.initialData,\n        updatedAt: action.hasInitialData ? Date.now() : 0\n      };\n\n    case actionFailed:\n      return _extends({}, state, {\n        failureCount: state.failureCount + 1\n      });\n\n    case actionMarkStale:\n      return _extends({}, state, {\n        isStale: true\n      });\n\n    case actionMarkGC:\n      {\n        return _extends({}, state, {\n          markedForGarbageCollection: true\n        });\n      }\n\n    case actionFetch:\n      return _extends({}, state, {\n        status: state.status === statusError ? statusLoading : state.status,\n        isFetching: true,\n        failureCount: 0\n      });\n\n    case actionSuccess:\n      return _extends({}, state, {\n        status: statusSuccess,\n        data: functionalUpdate(action.updater, state.data),\n        error: null,\n        isStale: false,\n        isFetching: false,\n        canFetchMore: action.canFetchMore,\n        updatedAt: Date.now(),\n        failureCount: 0\n      });\n\n    case actionError:\n      return _extends({}, state, {\n        isFetching: false,\n        isStale: true\n      }, !action.cancelled && {\n        status: statusError,\n        error: action.error\n      });\n\n    case actionSetState:\n      return functionalUpdate(action.updater, state);\n\n    default:\n      throw new Error();\n  }\n}\n\nvar visibilityChangeEvent = 'visibilitychange';\nvar focusEvent = 'focus';\n\nvar onWindowFocus = function onWindowFocus() {\n  var refetchAllOnWindowFocus = defaultConfigRef.current.refetchAllOnWindowFocus;\n\n  if (isDocumentVisible() && isOnline()) {\n    queryCaches.forEach(function (queryCache) {\n      return queryCache.refetchQueries(function (query) {\n        if (!query.instances.length) {\n          return false;\n        }\n\n        if (query.config.manual === true) {\n          return false;\n        }\n\n        if (query.shouldContinueRetryOnFocus) {\n          // delete promise, so `fetch` will create new one\n          delete query.promise;\n          return true;\n        }\n\n        if (typeof query.config.refetchOnWindowFocus === 'undefined') {\n          return refetchAllOnWindowFocus;\n        } else {\n          return query.config.refetchOnWindowFocus;\n        }\n      }).catch(Console.error);\n    });\n  }\n};\n\nvar removePreviousHandler;\n\nfunction setFocusHandler(callback) {\n  // Unsub the old watcher\n  if (removePreviousHandler) {\n    removePreviousHandler();\n  } // Sub the new watcher\n\n\n  removePreviousHandler = callback(onWindowFocus);\n}\n\nsetFocusHandler(function (handleFocus) {\n  var _window; // Listen to visibillitychange and focus\n\n\n  if (!isServer && ((_window = window) == null ? void 0 : _window.addEventListener)) {\n    window.addEventListener(visibilityChangeEvent, handleFocus, false);\n    window.addEventListener(focusEvent, handleFocus, false);\n    return function () {\n      // Be sure to unsubscribe if a new handler is set\n      window.removeEventListener(visibilityChangeEvent, handleFocus);\n      window.removeEventListener(focusEvent, handleFocus);\n    };\n  }\n});\n\nfunction useIsFetching() {\n  var queryCache = useQueryCache();\n\n  var _React$useState = React.useState({}),\n      state = _React$useState[0],\n      setState = _React$useState[1];\n\n  React.useEffect(function () {\n    return queryCache.subscribe(function () {\n      return setState({});\n    });\n  }, []);\n  return React.useMemo(function () {\n    return state && queryCache.isFetching;\n  }, [state]);\n}\n\nvar getDefaultState = function getDefaultState() {\n  return {\n    status: statusIdle,\n    data: undefined,\n    error: null\n  };\n};\n\nvar actionReset = {};\nvar actionLoading = {};\nvar actionResolve = {};\nvar actionReject = {};\n\nfunction mutationReducer(state, action) {\n  if (action.type === actionReset) {\n    return getDefaultState();\n  }\n\n  if (action.type === actionLoading) {\n    return {\n      status: statusLoading\n    };\n  }\n\n  if (action.type === actionResolve) {\n    return {\n      status: statusSuccess,\n      data: action.data\n    };\n  }\n\n  if (action.type === actionReject) {\n    return {\n      status: statusError,\n      error: action.error\n    };\n  }\n\n  throw new Error();\n}\n\nfunction useMutation(mutationFn, config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  var _React$useReducer = React.useReducer(mutationReducer, null, getDefaultState),\n      state = _React$useReducer[0],\n      unsafeDispatch = _React$useReducer[1];\n\n  var dispatch = useMountedCallback(unsafeDispatch);\n  var getMutationFn = useGetLatest(mutationFn);\n  var getConfig = useGetLatest(_extends({}, useConfigContext(), {}, config));\n  var latestMutationRef = React.useRef();\n  var mutate = React.useCallback(_async(function (variables, _temp) {\n    var _ref = _temp === void 0 ? {} : _temp,\n        _ref$onSuccess = _ref.onSuccess,\n        onSuccess = _ref$onSuccess === void 0 ? noop : _ref$onSuccess,\n        _ref$onError = _ref.onError,\n        onError = _ref$onError === void 0 ? noop : _ref$onError,\n        _ref$onSettled = _ref.onSettled,\n        onSettled = _ref$onSettled === void 0 ? noop : _ref$onSettled,\n        throwOnError = _ref.throwOnError;\n\n    var config = getConfig();\n    var mutationId = uid();\n    latestMutationRef.current = mutationId;\n\n    var isLatest = function isLatest() {\n      return latestMutationRef.current === mutationId;\n    };\n\n    dispatch({\n      type: actionLoading\n    });\n    var snapshotValue;\n    return _catch(function () {\n      return _await(config.onMutate(variables), function (_config$onMutate) {\n        snapshotValue = _config$onMutate;\n        var data;\n        return _invoke(function () {\n          if (isLatest()) {\n            return _await(getMutationFn()(variables), function (_getMutationFn) {\n              data = _getMutationFn;\n            });\n          }\n        }, function () {\n          return _invoke(function () {\n            if (isLatest()) {\n              return _awaitIgnored(onSuccess(data, variables));\n            }\n          }, function () {\n            return _invoke(function () {\n              if (isLatest()) {\n                return _awaitIgnored(config.onSuccess(data, variables));\n              }\n            }, function () {\n              return _invoke(function () {\n                if (isLatest()) {\n                  return _awaitIgnored(onSettled(data, null, variables));\n                }\n              }, function () {\n                return _invoke(function () {\n                  if (isLatest()) {\n                    return _awaitIgnored(config.onSettled(data, null, variables));\n                  }\n                }, function () {\n                  if (isLatest()) {\n                    dispatch({\n                      type: actionResolve,\n                      data: data\n                    });\n                  }\n\n                  return data;\n                });\n              });\n            });\n          });\n        });\n      });\n    }, function (error) {\n      return _invoke(function () {\n        if (isLatest()) {\n          Console.error(error);\n          return _awaitIgnored(onError(error, variables, snapshotValue));\n        }\n      }, function () {\n        return _invoke(function () {\n          if (isLatest()) {\n            return _awaitIgnored(config.onError(error, variables, snapshotValue));\n          }\n        }, function () {\n          return _invoke(function () {\n            if (isLatest()) {\n              return _awaitIgnored(onSettled(undefined, error, variables, snapshotValue));\n            }\n          }, function () {\n            return _invoke(function () {\n              if (isLatest()) {\n                return _awaitIgnored(config.onSettled(undefined, error, variables, snapshotValue));\n              }\n            }, function () {\n              if (isLatest()) {\n                dispatch({\n                  type: actionReject,\n                  error: error\n                });\n\n                if (throwOnError != null ? throwOnError : config.throwOnError) {\n                  throw error;\n                }\n              }\n            });\n          });\n        });\n      });\n    });\n  }), [dispatch, getConfig, getMutationFn]);\n  var reset = React.useCallback(function () {\n    return dispatch({\n      type: actionReset\n    });\n  }, [dispatch]);\n  React.useEffect(function () {\n    if (getConfig().useErrorBoundary && state.error) {\n      throw state.error;\n    }\n  }, [getConfig, state.error]);\n  return [mutate, _extends({}, state, {\n    reset: reset\n  })];\n}\n\nfunction useBaseQuery(queryKey, queryVariables, queryFn, config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  var instanceId = useUid();\n  config = _extends({}, useConfigContext(), {}, config);\n  var queryCache = useQueryCache();\n  var queryRef = React.useRef();\n\n  var newQuery = queryCache._buildQuery(queryKey, queryVariables, queryFn, config);\n\n  var useCachedQuery = queryRef.current && typeof queryRef.current.queryHash === 'undefined' && typeof newQuery.queryHash === 'undefined'; // Do not use new query with undefined queryHash, if previous query also had undefined queryHash.\n  // Otherwise this will cause infinite loop.\n\n  if (!useCachedQuery) {\n    queryRef.current = newQuery;\n  }\n\n  var query = queryRef.current;\n\n  var _React$useState = React.useState(),\n      unsafeRerender = _React$useState[1];\n\n  var rerender = useMountedCallback(unsafeRerender);\n  var getLatestConfig = useGetLatest(config);\n  var refetch = React.useCallback(_async(function (_ref) {\n    if (_ref === void 0) {\n      _ref = {};\n    }\n\n    var _ref2 = _ref,\n        throwOnError = _ref2.throwOnError,\n        rest = _objectWithoutPropertiesLoose(_ref2, [\"throwOnError\"]);\n\n    return _catch(function () {\n      return _await(query.fetch(rest));\n    }, function (err) {\n      if (throwOnError) {\n        throw err;\n      }\n    });\n  }), [query]);\n  query.suspenseInstance = {\n    onSuccess: function onSuccess(data) {\n      return getLatestConfig().onSuccess(data);\n    },\n    onError: function onError(err) {\n      return getLatestConfig().onError(err);\n    },\n    onSettled: function onSettled(data, err) {\n      return getLatestConfig().onSettled(data, err);\n    }\n  }; // After mount, subscribe to the query\n\n  React.useEffect(function () {\n    // Update the instance to the query again, but not as a placeholder\n    query.updateInstance({\n      id: instanceId,\n      onStateUpdate: function onStateUpdate() {\n        return rerender({});\n      },\n      onSuccess: function onSuccess(data) {\n        return getLatestConfig().onSuccess(data);\n      },\n      onError: function onError(err) {\n        return getLatestConfig().onError(err);\n      },\n      onSettled: function onSettled(data, err) {\n        return getLatestConfig().onSettled(data, err);\n      }\n    });\n    return query.subscribe(instanceId);\n  }, [getLatestConfig, instanceId, query, rerender]);\n  React.useEffect(function () {\n    // Perform the initial fetch for this query if necessary\n    if (!getLatestConfig().manual && // Don't auto fetch if config is set to manual query\n    !query.wasPrefetched && // Don't double fetch for prefetched queries\n    !query.wasSuspended && // Don't double fetch for suspense\n    query.state.isStale && ( // Only refetch if stale\n    getLatestConfig().refetchOnMount || query.instances.length === 1)) {\n      refetch().catch(Console.error);\n    }\n\n    query.wasPrefetched = false;\n    query.wasSuspended = false;\n  }, [getLatestConfig, query, refetch]); // Handle refetch interval\n\n  React.useEffect(function () {\n    var query = queryRef.current;\n\n    if (config.refetchInterval && (!query.currentRefetchInterval || // shorter interval should override previous one\n    config.refetchInterval < query.currentRefetchInterval)) {\n      query.currentRefetchInterval = config.refetchInterval;\n      clearInterval(query.refetchIntervalId);\n      query.refetchIntervalId = setInterval(function () {\n        if (isDocumentVisible() || config.refetchIntervalInBackground) {\n          refetch().catch(Console.error);\n        }\n      }, config.refetchInterval);\n      return function () {\n        clearInterval(query.refetchIntervalId);\n        delete query.refetchIntervalId;\n        delete query.currentRefetchInterval;\n      };\n    }\n  }, [config.refetchInterval, config.refetchIntervalInBackground, refetch]);\n  return _extends({}, query.state, {\n    config: config,\n    query: query,\n    refetch: refetch\n  });\n}\n\nfunction useQuery() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  var query = useBaseQuery.apply(void 0, getQueryArgs(args));\n  handleSuspense(query);\n  return query;\n}\n\nfunction usePaginatedQuery() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  var _getQueryArgs = getQueryArgs(args),\n      queryKey = _getQueryArgs[0],\n      queryVariables = _getQueryArgs[1],\n      queryFn = _getQueryArgs[2],\n      _getQueryArgs$ = _getQueryArgs[3],\n      config = _getQueryArgs$ === void 0 ? {} : _getQueryArgs$;\n\n  var lastDataRef = React.useRef();\n\n  if (!queryKey) {\n    lastDataRef.current = undefined;\n  } // If latestData is set, don't use initialData\n\n\n  if (typeof lastDataRef.current !== 'undefined') {\n    delete config.initialData;\n  }\n\n  var query = useBaseQuery(queryKey, queryVariables, queryFn, config);\n  var latestData = query.data,\n      status = query.status;\n  React.useEffect(function () {\n    if (status === 'success' && typeof latestData !== 'undefined') {\n      lastDataRef.current = latestData;\n    }\n  }, [latestData, status]);\n  var resolvedData = latestData;\n\n  if (typeof resolvedData === 'undefined') {\n    resolvedData = lastDataRef.current;\n  }\n\n  if (typeof resolvedData !== 'undefined') {\n    status = 'success';\n  }\n\n  var paginatedQuery = _extends({}, query, {\n    resolvedData: resolvedData,\n    latestData: latestData,\n    status: status\n  });\n\n  handleSuspense(paginatedQuery);\n  return paginatedQuery;\n}\n\nfunction useInfiniteQuery() {\n  var queryInfoRef = React.useRef();\n\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  var _getQueryArgs = getQueryArgs(args),\n      queryKey = _getQueryArgs[0],\n      queryVariables = _getQueryArgs[1],\n      queryFn = _getQueryArgs[2],\n      _getQueryArgs$ = _getQueryArgs[3],\n      config = _getQueryArgs$ === void 0 ? {} : _getQueryArgs$;\n\n  var getFetchMore = config.getFetchMore;\n  var getGetFetchMore = useGetLatest(getFetchMore); // The default queryFn will query all pages and map them together\n\n  var originalQueryFn = queryFn;\n  queryFn = _async(function () {\n    var _interrupt = false;\n    var data = [];\n    var pageVariables = [].concat(queryInfoRef.current.query.pageVariables);\n    var rebuiltPageVariables = [];\n    return _continue(_do(function () {\n      var args = pageVariables.shift();\n      return _invokeIgnored(function () {\n        if (!data.length) {\n          var _push3 = data.push; // the first page query doesn't need to be rebuilt\n\n          return _await(originalQueryFn.apply(void 0, args), function (_originalQueryFn) {\n            _push3.call(data, _originalQueryFn);\n\n            rebuiltPageVariables.push(args);\n          });\n        } else {\n          // get an up-to-date cursor based on the previous data set\n          var nextCursor = getGetFetchMore()(data[data.length - 1], data); // break early if there's no next cursor\n          // otherwise we'll start from the beginning\n          // which will cause unwanted duplication\n\n          if (!nextCursor) {\n            _interrupt = true;\n            return;\n          }\n\n          var pageArgs = [].concat(args.slice(0, -1), [nextCursor]);\n          var _push4 = data.push;\n          return _await(originalQueryFn.apply(void 0, pageArgs), function (_originalQueryFn2) {\n            _push4.call(data, _originalQueryFn2);\n\n            rebuiltPageVariables.push(pageArgs);\n          });\n        }\n      });\n    }, function () {\n      return !_interrupt && !!pageVariables.length;\n    }), function () {\n      queryInfoRef.current.query.canFetchMore = getGetFetchMore()(data[data.length - 1], data);\n      queryInfoRef.current.query.pageVariables = rebuiltPageVariables;\n      return data;\n    });\n  });\n  var queryInfo = useBaseQuery(queryKey, queryVariables, queryFn, config);\n\n  if (typeof queryInfo.query.canFetchMore === 'undefined' && typeof queryInfo.data !== 'undefined') {\n    queryInfo.query.canFetchMore = getGetFetchMore()(queryInfo.data[queryInfo.data.length - 1], queryInfo.data);\n  }\n\n  queryInfoRef.current = queryInfo;\n  var refetch = queryInfo.refetch,\n      _queryInfo$data = queryInfo.data,\n      data = _queryInfo$data === void 0 ? [] : _queryInfo$data,\n      canFetchMore = queryInfo.query.canFetchMore; // Here we seed the pageVariabes for the query\n\n  if (!queryInfo.query.pageVariables) {\n    queryInfo.query.pageVariables = [[].concat(queryInfo.query.queryKey, queryInfo.query.queryVariables)];\n  }\n\n  var fetchMore = React.useCallback(function (fetchMoreInfo) {\n    if (fetchMoreInfo === void 0) {\n      fetchMoreInfo = queryInfoRef.current.query.canFetchMore;\n    }\n\n    return queryInfoRef.current.query.canFetchMore ? refetch({\n      force: true,\n      __queryFn: _async(function () {\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n\n        return _finallyRethrows(function () {\n          queryInfoRef.current.query.setState(function (old) {\n            return _extends({}, old, {\n              isFetchingMore: true\n            });\n          });\n          var newArgs = [].concat(args, [fetchMoreInfo]);\n          queryInfoRef.current.query.pageVariables.push(newArgs);\n          var _queryInfoRef$current = queryInfoRef.current.data;\n          return _await(originalQueryFn.apply(void 0, newArgs), function (_originalQueryFn3) {\n            var data = [].concat(_queryInfoRef$current, [_originalQueryFn3]);\n            queryInfoRef.current.query.canFetchMore = getGetFetchMore()(data[data.length - 1], data);\n            return data;\n          });\n        }, function (_wasThrown, _result) {\n          queryInfoRef.current.query.setState(function (old) {\n            return _extends({}, old, {\n              isFetchingMore: false\n            });\n          });\n          return _rethrow(_wasThrown, _result);\n        });\n      })\n    }) : void 0;\n  }, [getGetFetchMore, originalQueryFn, refetch]);\n  handleSuspense(queryInfo);\n  return _extends({}, queryInfo, {\n    data: data,\n    canFetchMore: canFetchMore,\n    fetchMore: fetchMore\n  });\n}\n\nexport { ReactQueryCacheProvider, ReactQueryConfigProvider, deepIncludes, makeQueryCache, queryCache, setConsole, setFocusHandler, stableStringify, statusError, statusIdle, statusLoading, statusSuccess, useInfiniteQuery, useIsFetching, useMutation, usePaginatedQuery, useQuery, useQueryCache };","map":{"version":3,"sources":["../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/utils.js","../src/config.js","../src/queryCache.js","../src/setFocusHandler.js","../src/useIsFetching.js","../src/useMutation.js","../src/useBaseQuery.js","../src/useQuery.js","../src/usePaginatedQuery.js","../src/useInfiniteQuery.js"],"names":["_Pact","result","state","callback","_settle","value","_this","onFulfilled","onRejected","pact","observer","thenable","args","i","arguments","Promise","f","then","_iteratorSymbol","Symbol","_asyncIteratorSymbol","body","_isSettledPact","awaitBody","shouldContinue","test","reject","recover","finalizer","statusIdle","statusLoading","statusError","statusSuccess","_uid","uid","cancelledError","isServer","noop","identity","Console","console","error","warn","log","ref","React","updater","Object","JSON","a","Array","deepIncludes","b","document","navigator","isObject","queryKey","variables","queryFn","config","mounted","queryInfo","setTimeout","length","deepEqual","keys","key","configContext","DEFAULTS","retry","retryDelay","Math","staleTime","cacheTime","refetchAllOnWindowFocus","refetchInterval","suspense","queryKeySerializerFn","queryFnParamsFilter","throwOnError","useErrorBoundary","onMutate","onSuccess","onError","onSettled","refetchOnMount","isDataEqual","defaultConfigRef","current","children","configContextValue","newConfig","defaultQueryKeySerializerFn","queryHash","stableStringify","queryCache","makeQueryCache","queryCacheContext","queryCaches","cache","actionInit","actionFailed","actionMarkStale","actionMarkGC","actionFetch","actionSuccess","actionError","actionSetState","listeners","queries","isFetching","notifyGlobalListeners","query","acc","d","findQueries","exact","predicate","foundQueries","clearTimeout","force","queryVariables","makeQuery","getQueryArgs","options","reducer","noQueryHash","initialData","hasInitialData","isStale","manual","initialStatus","instances","type","dispatch","found","instance","onStateUpdate","tryFetchData","promise","isDocumentVisible","delay","functionalUpdate","resolve","__queryFn","callbackInstances","cancelled","action","status","canFetchMore","failureCount","markedForGarbageCollection","data","updatedAt","Date","visibilityChangeEvent","focusEvent","onWindowFocus","isOnline","removePreviousHandler","setFocusHandler","window","useQueryCache","setState","getDefaultState","actionReset","actionLoading","actionResolve","actionReject","unsafeDispatch","useMountedCallback","getMutationFn","useGetLatest","getConfig","useConfigContext","latestMutationRef","mutate","mutationId","isLatest","snapshotValue","reset","instanceId","useUid","queryRef","newQuery","useCachedQuery","unsafeRerender","rerender","getLatestConfig","refetch","rest","id","clearInterval","setInterval","useBaseQuery","handleSuspense","lastDataRef","latestData","resolvedData","paginatedQuery","queryInfoRef","getFetchMore","getGetFetchMore","originalQueryFn","pageVariables","rebuiltPageVariables","nextCursor","pageArgs","fetchMore","fetchMoreInfo","isFetchingMore","newArgs"],"mappings":"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","sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import React from 'react'\n\n//\n\nexport const statusIdle = 'idle'\nexport const statusLoading = 'loading'\nexport const statusError = 'error'\nexport const statusSuccess = 'success'\n\nlet _uid = 0\nexport const uid = () => _uid++\nexport const cancelledError = {}\nexport let globalStateListeners = []\nexport const isServer = typeof window === 'undefined'\nexport const noop = () => {}\nexport const identity = d => d\nexport let Console = console || { error: noop, warn: noop, log: noop }\n\nexport function useUid() {\n  const ref = React.useRef(null)\n\n  if (ref.current === null) {\n    ref.current = uid()\n  }\n\n  return ref.current\n}\n\nexport function setConsole(c) {\n  Console = c\n}\n\nexport function useGetLatest(obj) {\n  const ref = React.useRef()\n  ref.current = obj\n\n  return React.useCallback(() => ref.current, [])\n}\n\nexport function functionalUpdate(updater, old) {\n  return typeof updater === 'function' ? updater(old) : updater\n}\n\nexport function stableStringifyReplacer(_, value) {\n  return isObject(value)\n    ? Object.assign(\n        {},\n        ...Object.keys(value)\n          .sort()\n          .map(key => ({\n            [key]: value[key],\n          }))\n      )\n    : value\n}\n\nexport function stableStringify(obj) {\n  return JSON.stringify(obj, stableStringifyReplacer)\n}\n\nexport function isObject(a) {\n  return a && typeof a === 'object' && !Array.isArray(a)\n}\n\nexport function deepIncludes(a, b) {\n  if (a === b) {\n    return true\n  }\n\n  if (typeof a !== typeof b) {\n    return false\n  }\n\n  if (typeof a === 'object') {\n    return !Object.keys(b).some(key => !deepIncludes(a[key], b[key]))\n  }\n\n  return false\n}\n\nexport function isDocumentVisible() {\n  return (\n    typeof document === 'undefined' ||\n    document.visibilityState === undefined ||\n    document.visibilityState === 'visible' ||\n    document.visibilityState === 'prerender'\n  )\n}\n\nexport function isOnline() {\n  return navigator.onLine === undefined || navigator.onLine\n}\n\nexport function getQueryArgs(args) {\n  if (isObject(args[0])) {\n    if (\n      args[0].hasOwnProperty('queryKey') &&\n      args[0].hasOwnProperty('queryFn')\n    ) {\n      const { queryKey, variables = [], queryFn, config = {} } = args[0]\n      return [queryKey, variables, queryFn, config]\n    } else {\n      throw new Error('queryKey and queryFn keys are required.')\n    }\n  }\n\n  if (typeof args[2] === 'function') {\n    const [queryKey, variables = [], queryFn, config = {}] = args\n    return [queryKey, variables, queryFn, config]\n  }\n\n  const [queryKey, queryFn, config = {}] = args\n\n  return [queryKey, [], queryFn, config]\n}\n\nexport function useMountedCallback(callback) {\n  const mounted = React.useRef(false)\n  React[isServer ? 'useEffect' : 'useLayoutEffect'](() => {\n    mounted.current = true\n    return () => (mounted.current = false)\n  }, [])\n  return React.useCallback(\n    (...args) => (mounted.current ? callback(...args) : void 0),\n    [callback]\n  )\n}\n\nexport function handleSuspense(queryInfo) {\n  if (queryInfo.config.suspense || queryInfo.config.useErrorBoundary) {\n    if (queryInfo.status === statusError) {\n      setTimeout(() => {\n        queryInfo.query.state.status = 'loading'\n      })\n      throw queryInfo.error\n    }\n  }\n\n  if (queryInfo.config.suspense) {\n    if (queryInfo.status === statusLoading) {\n      queryInfo.query.wasSuspended = true\n      throw queryInfo.refetch()\n    }\n  }\n}\n\n// This deep-equal is directly based on https://github.com/epoberezkin/fast-deep-equal.\n// The parts for comparing any non-JSON-supported values has been removed\nexport function deepEqual(a, b) {\n  if (a === b) return true\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    var length, i, keys\n    if (Array.isArray(a)) {\n      length = a.length\n      // eslint-disable-next-line eqeqeq\n      if (length != b.length) return false\n      for (i = length; i-- !== 0; ) if (!deepEqual(a[i], b[i])) return false\n      return true\n    }\n\n    if (a.valueOf !== Object.prototype.valueOf)\n      return a.valueOf() === b.valueOf()\n\n    keys = Object.keys(a)\n    length = keys.length\n    if (length !== Object.keys(b).length) return false\n\n    for (i = length; i-- !== 0; )\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false\n\n    for (i = length; i-- !== 0; ) {\n      var key = keys[i]\n\n      if (!deepEqual(a[key], b[key])) return false\n    }\n\n    return true\n  }\n\n  // true if both NaN, false otherwise\n  // eslint-disable-next-line no-self-compare\n  return a !== a && b !== b\n}\n","import React from 'react'\nimport { noop, stableStringify, identity, deepEqual } from './utils'\n\nexport const configContext = React.createContext()\n\nconst DEFAULTS = {\n  retry: 3,\n  retryDelay: attemptIndex => Math.min(1000 * 2 ** attemptIndex, 30000),\n  staleTime: 0,\n  cacheTime: 5 * 60 * 1000,\n  refetchAllOnWindowFocus: true,\n  refetchInterval: false,\n  suspense: false,\n  queryKeySerializerFn: defaultQueryKeySerializerFn,\n  queryFnParamsFilter: identity,\n  throwOnError: false,\n  useErrorBoundary: undefined, // this will default to the suspense value\n  onMutate: noop,\n  onSuccess: noop,\n  onError: noop,\n  onSettled: noop,\n  refetchOnMount: true,\n  isDataEqual: deepEqual,\n}\n\nexport const defaultConfigRef = {\n  current: DEFAULTS,\n}\n\nexport function useConfigContext() {\n  return React.useContext(configContext) || defaultConfigRef.current\n}\n\nexport function ReactQueryConfigProvider({ config, children }) {\n  let configContextValue = React.useContext(configContext)\n\n  const newConfig = React.useMemo(() => {\n    const newConfig = {\n      ...(configContextValue || defaultConfigRef.current),\n      ...config,\n    }\n\n    // Default useErrorBoundary to the suspense value\n    if (typeof newConfig.useErrorBoundary === 'undefined') {\n      newConfig.useErrorBoundary = newConfig.suspense\n    }\n\n    return newConfig\n  }, [config, configContextValue])\n\n  React.useEffect(() => {\n    // restore previous config on unmount\n    return () => {\n      defaultConfigRef.current = { ...(configContextValue || DEFAULTS) }\n\n      // Default useErrorBoundary to the suspense value\n      if (typeof defaultConfigRef.current.useErrorBoundary === 'undefined') {\n        defaultConfigRef.current.useErrorBoundary =\n          defaultConfigRef.current.suspense\n      }\n    }\n  }, [configContextValue])\n\n  if (!configContextValue) {\n    defaultConfigRef.current = newConfig\n  }\n\n  return (\n    <configContext.Provider value={newConfig}>\n      {children}\n    </configContext.Provider>\n  )\n}\n\nexport function defaultQueryKeySerializerFn(queryKey) {\n  if (!queryKey) {\n    return []\n  }\n\n  if (typeof queryKey === 'function') {\n    try {\n      return defaultQueryKeySerializerFn(queryKey())\n    } catch {\n      return []\n    }\n  }\n\n  if (typeof queryKey === 'string') {\n    queryKey = [queryKey]\n  }\n\n  const queryHash = stableStringify(queryKey)\n  queryKey = JSON.parse(queryHash)\n\n  return [queryHash, queryKey]\n}\n","import React from 'react'\nimport {\n  isServer,\n  functionalUpdate,\n  cancelledError,\n  isDocumentVisible,\n  statusLoading,\n  statusSuccess,\n  statusError,\n  getQueryArgs,\n  deepIncludes,\n  noop,\n} from './utils'\nimport { defaultConfigRef } from './config'\n\nexport const queryCache = makeQueryCache()\n\nexport const queryCacheContext = React.createContext(queryCache)\n\nexport const queryCaches = [queryCache]\n\nexport function useQueryCache() {\n  return React.useContext(queryCacheContext)\n}\n\nexport function ReactQueryCacheProvider({ queryCache, children }) {\n  const cache = React.useMemo(() => queryCache || makeQueryCache(), [\n    queryCache,\n  ])\n\n  React.useEffect(() => {\n    queryCaches.push(cache)\n\n    return () => {\n      // remove the cache from the active list\n      const i = queryCaches.indexOf(cache)\n      if (i >= 0) {\n        queryCaches.splice(i, 1)\n      }\n      // if the cache was created by us, we need to tear it down\n      if (queryCache == null) {\n        cache.clear()\n      }\n    }\n  }, [cache, queryCache])\n\n  return (\n    <queryCacheContext.Provider value={cache}>\n      {children}\n    </queryCacheContext.Provider>\n  )\n}\n\nconst actionInit = {}\nconst actionFailed = {}\nconst actionMarkStale = {}\nconst actionMarkGC = {}\nconst actionFetch = {}\nconst actionSuccess = {}\nconst actionError = {}\nconst actionSetState = {}\n\nexport function makeQueryCache() {\n  const listeners = []\n\n  const cache = {\n    queries: {},\n    isFetching: 0,\n  }\n\n  const notifyGlobalListeners = () => {\n    cache.isFetching = Object.values(cache.queries).reduce(\n      (acc, query) => (query.state.isFetching ? acc + 1 : acc),\n      0\n    )\n    listeners.forEach(d => d(cache))\n  }\n\n  cache.subscribe = cb => {\n    listeners.push(cb)\n    return () => {\n      listeners.splice(listeners.indexOf(cb), 1)\n    }\n  }\n\n  cache.clear = () => {\n    Object.values(cache.queries).forEach(query => query.clear())\n    cache.queries = {}\n    notifyGlobalListeners()\n  }\n\n  const findQueries = (predicate, { exact } = {}) => {\n    if (typeof predicate !== 'function') {\n      const [\n        queryHash,\n        queryKey,\n      ] = defaultConfigRef.current.queryKeySerializerFn(predicate)\n      predicate = d =>\n        exact ? d.queryHash === queryHash : deepIncludes(d.queryKey, queryKey)\n    }\n\n    return Object.values(cache.queries).filter(predicate)\n  }\n\n  cache.getQueries = findQueries\n\n  cache.getQuery = queryKey => findQueries(queryKey, { exact: true })[0]\n\n  cache.getQueryData = queryKey => cache.getQuery(queryKey)?.state.data\n\n  cache.removeQueries = (predicate, { exact } = {}) => {\n    const foundQueries = findQueries(predicate, { exact })\n\n    foundQueries.forEach(query => {\n      clearTimeout(query.staleTimeout)\n      delete cache.queries[query.queryHash]\n    })\n\n    if (foundQueries.length) {\n      notifyGlobalListeners()\n    }\n  }\n\n  cache.cancelQueries = (predicate, { exact } = {}) => {\n    const foundQueries = findQueries(predicate, { exact })\n\n    foundQueries.forEach(query => {\n      query.cancel()\n    })\n\n    if (foundQueries.length) {\n      notifyGlobalListeners()\n    }\n  }\n\n  cache.refetchQueries = async (\n    predicate,\n    { exact, throwOnError, force } = {}\n  ) => {\n    const foundQueries =\n      predicate === true\n        ? Object.values(cache.queries)\n        : findQueries(predicate, { exact })\n\n    try {\n      return await Promise.all(\n        foundQueries.map(query => query.fetch({ force }))\n      )\n    } catch (err) {\n      if (throwOnError) {\n        throw err\n      }\n    }\n  }\n\n  cache._buildQuery = (userQueryKey, queryVariables, queryFn, config) => {\n    let [queryHash, queryKey] = config.queryKeySerializerFn(userQueryKey)\n\n    let query = cache.queries[queryHash]\n\n    if (query) {\n      Object.assign(query, { queryVariables, queryFn })\n      query.config = { ...query.config, ...config }\n    } else {\n      query = makeQuery({\n        cache,\n        queryKey,\n        queryHash,\n        queryVariables,\n        queryFn,\n        config,\n      })\n\n      // If the query started with data, schedule\n      // a stale timeout\n      if (!isServer && query.state.data) {\n        query.scheduleStaleTimeout()\n\n        // Simulate a query healing process\n        query.heal()\n        // Schedule for garbage collection in case\n        // nothing subscribes to this query\n        query.scheduleGarbageCollection()\n      }\n\n      if (query.queryHash) {\n        if (!isServer) {\n          cache.queries[queryHash] = query\n          // Here, we setTimeout so as to not trigger\n          // any setState's in parent components in the\n          // middle of the render phase.\n          setTimeout(() => {\n            notifyGlobalListeners()\n          })\n        }\n      }\n    }\n\n    return query\n  }\n\n  cache.prefetchQuery = async (...args) => {\n    let [\n      queryKey,\n      queryVariables,\n      queryFn,\n      { force, ...config },\n    ] = getQueryArgs(args)\n\n    config = {\n      ...defaultConfigRef.current,\n      ...config,\n    }\n\n    const query = cache._buildQuery(queryKey, queryVariables, queryFn, config)\n\n    // Don't prefetch queries that are fresh, unless force is passed\n    if (query.state.isStale || force) {\n      // Trigger a fetch and return the promise\n      try {\n        const res = await query.fetch({ force })\n        query.wasPrefetched = true\n        return res\n      } catch (err) {\n        if (config.throwOnError) {\n          throw err\n        }\n      }\n    }\n\n    return query.state.data\n  }\n\n  cache.setQueryData = (queryKey, updater, { exact, ...config } = {}) => {\n    let queries = findQueries(queryKey, { exact })\n\n    if (!queries.length && typeof queryKey !== 'function') {\n      queries = [\n        cache._buildQuery(queryKey, undefined, () => new Promise(noop), {\n          ...defaultConfigRef.current,\n          ...config,\n        }),\n      ]\n    }\n\n    queries.forEach(d => d.setData(updater))\n  }\n\n  function makeQuery(options) {\n    const queryCache = options.cache\n    const reducer = options.config.queryReducer || defaultQueryReducer\n\n    const noQueryHash = typeof options.queryHash === 'undefined'\n\n    const initialData =\n      typeof options.config.initialData === 'function'\n        ? options.config.initialData()\n        : options.config.initialData\n\n    const hasInitialData = typeof initialData !== 'undefined'\n\n    const isStale = noQueryHash ? true : !hasInitialData\n\n    const manual = options.config.manual\n\n    const initialStatus =\n      noQueryHash || manual || hasInitialData ? statusSuccess : statusLoading\n\n    const query = {\n      ...options,\n      instances: [],\n      state: reducer(undefined, {\n        type: actionInit,\n        initialStatus,\n        initialData,\n        hasInitialData,\n        isStale,\n        manual,\n      }),\n    }\n\n    const dispatch = action => {\n      query.state = reducer(query.state, action)\n      query.instances.forEach(d => d.onStateUpdate(query.state))\n      notifyGlobalListeners()\n    }\n\n    query.scheduleStaleTimeout = () => {\n      if (query.config.staleTime === Infinity) {\n        return\n      }\n      query.staleTimeout = setTimeout(() => {\n        if (queryCache.getQuery(query.queryKey)) {\n          dispatch({ type: actionMarkStale })\n        }\n      }, query.config.staleTime)\n    }\n\n    query.scheduleGarbageCollection = () => {\n      if (query.config.cacheTime === Infinity) {\n        return\n      }\n      dispatch({ type: actionMarkGC })\n      query.cacheTimeout = setTimeout(\n        () => {\n          cache.removeQueries(\n            d =>\n              d.state.markedForGarbageCollection &&\n              d.queryHash === query.queryHash\n          )\n        },\n        typeof query.state.data === 'undefined' &&\n          query.state.status !== 'error'\n          ? 0\n          : query.config.cacheTime\n      )\n    }\n\n    query.heal = () => {\n      // Stop the query from being garbage collected\n      clearTimeout(query.cacheTimeout)\n\n      // Mark the query as not cancelled\n      query.cancelled = null\n    }\n\n    query.cancel = () => {\n      query.cancelled = cancelledError\n\n      if (query.cancelPromises) {\n        query.cancelPromises()\n      }\n\n      delete query.promise\n\n      notifyGlobalListeners()\n    }\n\n    query.updateInstance = instance => {\n      let found = query.instances.find(d => d.id === instance.id)\n\n      if (found) {\n        Object.assign(found, instance)\n      } else {\n        found = {\n          onStateUpdate: noop,\n          ...instance,\n        }\n        query.instances.push(instance)\n      }\n    }\n\n    query.subscribe = instanceId => {\n      query.heal()\n\n      // Return the unsubscribe function\n      return () => {\n        query.instances = query.instances.filter(d => d.id !== instanceId)\n\n        if (!query.instances.length) {\n          query.cancel()\n\n          // Schedule garbage collection\n          query.scheduleGarbageCollection()\n        }\n      }\n    }\n\n    // Set up the fetch function\n    const tryFetchData = async (queryFn, ...args) => {\n      try {\n        // Perform the query\n        const promise = queryFn(...query.config.queryFnParamsFilter(args))\n\n        query.cancelPromises = () => promise.cancel?.()\n\n        const data = await promise\n        delete query.shouldContinueRetryOnFocus\n\n        delete query.cancelPromises\n        if (query.cancelled) throw query.cancelled\n\n        return data\n      } catch (error) {\n        delete query.cancelPromises\n        if (query.cancelled) throw query.cancelled\n\n        // If we fail, increase the failureCount\n        dispatch({ type: actionFailed })\n\n        // Do we need to retry the request?\n        if (\n          query.config.retry === true ||\n          query.state.failureCount <= query.config.retry ||\n          (typeof query.config.retry === 'function' &&\n            query.config.retry(query.state.failureCount, error))\n        ) {\n          // Only retry if the document is visible\n          if (!isDocumentVisible()) {\n            // set this flag to continue fetch retries on focus\n            query.shouldContinueRetryOnFocus = true\n            return new Promise(noop)\n          }\n\n          delete query.shouldContinueRetryOnFocus\n\n          // Determine the retryDelay\n          const delay = functionalUpdate(\n            query.config.retryDelay,\n            query.state.failureCount\n          )\n\n          // Return a new promise with the retry\n          return await new Promise((resolve, reject) => {\n            // Keep track of the retry timeout\n            setTimeout(async () => {\n              if (query.cancelled) return reject(query.cancelled)\n\n              try {\n                const data = await tryFetchData(queryFn, ...args)\n                if (query.cancelled) return reject(query.cancelled)\n                resolve(data)\n              } catch (error) {\n                if (query.cancelled) return reject(query.cancelled)\n                reject(error)\n              }\n            }, delay)\n          })\n        }\n\n        throw error\n      }\n    }\n\n    query.fetch = async ({ force, __queryFn = query.queryFn } = {}) => {\n      // Don't refetch fresh queries that don't have a queryHash\n\n      if (!query.queryHash || (!query.state.isStale && !force)) {\n        return\n      }\n\n      // Create a new promise for the query cache if necessary\n      if (!query.promise) {\n        query.promise = (async () => {\n          // If there are any retries pending for this query, kill them\n          query.cancelled = null\n\n          const callbackInstances = [...query.instances]\n\n          if (query.wasSuspended) {\n            callbackInstances.unshift(query.suspenseInstance)\n          }\n\n          try {\n            // Set up the query refreshing state\n            dispatch({ type: actionFetch })\n\n            // Try to fetch\n            let data = await tryFetchData(\n              __queryFn,\n              ...query.queryKey,\n              ...query.queryVariables\n            )\n\n            query.setData(old =>\n              query.config.isDataEqual(old, data) ? old : data\n            )\n\n            callbackInstances.forEach(\n              instance =>\n                instance.onSuccess && instance.onSuccess(query.state.data)\n            )\n\n            callbackInstances.forEach(\n              instance =>\n                instance.onSettled && instance.onSettled(query.state.data, null)\n            )\n\n            delete query.promise\n\n            return data\n          } catch (error) {\n            dispatch({\n              type: actionError,\n              cancelled: error === query.cancelled,\n              error,\n            })\n\n            delete query.promise\n\n            if (error !== query.cancelled) {\n              callbackInstances.forEach(\n                instance => instance.onError && instance.onError(error)\n              )\n\n              callbackInstances.forEach(\n                instance =>\n                  instance.onSettled && instance.onSettled(undefined, error)\n              )\n\n              throw error\n            }\n          }\n        })()\n      }\n\n      return query.promise\n    }\n\n    query.setState = updater => dispatch({ type: actionSetState, updater })\n\n    query.setData = updater => {\n      // Set data and mark it as cached\n      dispatch({ type: actionSuccess, updater })\n\n      // Schedule a fresh invalidation!\n      clearTimeout(query.staleTimeout)\n      query.scheduleStaleTimeout()\n    }\n\n    query.clear = () => {\n      clearTimeout(query.staleTimeout)\n      clearTimeout(query.cacheTimeout)\n      query.cancel()\n    }\n\n    return query\n  }\n\n  return cache\n}\n\nexport function defaultQueryReducer(state, action) {\n  switch (action.type) {\n    case actionInit:\n      return {\n        status: action.initialStatus,\n        error: null,\n        isFetching:\n          action.hasInitialData || action.manual\n            ? false\n            : action.initialStatus === 'loading',\n        canFetchMore: false,\n        failureCount: 0,\n        isStale: action.isStale,\n        markedForGarbageCollection: false,\n        data: action.initialData,\n        updatedAt: action.hasInitialData ? Date.now() : 0,\n      }\n    case actionFailed:\n      return {\n        ...state,\n        failureCount: state.failureCount + 1,\n      }\n    case actionMarkStale:\n      return {\n        ...state,\n        isStale: true,\n      }\n    case actionMarkGC: {\n      return {\n        ...state,\n        markedForGarbageCollection: true,\n      }\n    }\n    case actionFetch:\n      return {\n        ...state,\n        status: state.status === statusError ? statusLoading : state.status,\n        isFetching: true,\n        failureCount: 0,\n      }\n    case actionSuccess:\n      return {\n        ...state,\n        status: statusSuccess,\n        data: functionalUpdate(action.updater, state.data),\n        error: null,\n        isStale: false,\n        isFetching: false,\n        canFetchMore: action.canFetchMore,\n        updatedAt: Date.now(),\n        failureCount: 0,\n      }\n    case actionError:\n      return {\n        ...state,\n        isFetching: false,\n        isStale: true,\n        ...(!action.cancelled && {\n          status: statusError,\n          error: action.error,\n        }),\n      }\n    case actionSetState:\n      return functionalUpdate(action.updater, state)\n    default:\n      throw new Error()\n  }\n}\n","import { isOnline, isDocumentVisible, Console, isServer } from './utils'\nimport { defaultConfigRef } from './config'\nimport { queryCaches } from './queryCache'\n\nconst visibilityChangeEvent = 'visibilitychange'\nconst focusEvent = 'focus'\n\nconst onWindowFocus = () => {\n  const { refetchAllOnWindowFocus } = defaultConfigRef.current\n\n  if (isDocumentVisible() && isOnline()) {\n    queryCaches.forEach(queryCache =>\n      queryCache\n        .refetchQueries(query => {\n          if (!query.instances.length) {\n            return false\n          }\n\n          if (query.config.manual === true) {\n            return false\n          }\n\n          if (query.shouldContinueRetryOnFocus) {\n            // delete promise, so `fetch` will create new one\n            delete query.promise\n            return true\n          }\n\n          if (typeof query.config.refetchOnWindowFocus === 'undefined') {\n            return refetchAllOnWindowFocus\n          } else {\n            return query.config.refetchOnWindowFocus\n          }\n        })\n        .catch(Console.error)\n    )\n  }\n}\n\nlet removePreviousHandler\n\nexport function setFocusHandler(callback) {\n  // Unsub the old watcher\n  if (removePreviousHandler) {\n    removePreviousHandler()\n  }\n  // Sub the new watcher\n  removePreviousHandler = callback(onWindowFocus)\n}\n\nsetFocusHandler(handleFocus => {\n  // Listen to visibillitychange and focus\n  if (!isServer && window?.addEventListener) {\n    window.addEventListener(visibilityChangeEvent, handleFocus, false)\n    window.addEventListener(focusEvent, handleFocus, false)\n\n    return () => {\n      // Be sure to unsubscribe if a new handler is set\n      window.removeEventListener(visibilityChangeEvent, handleFocus)\n      window.removeEventListener(focusEvent, handleFocus)\n    }\n  }\n})\n","import React from 'react'\n\nimport { useQueryCache } from './queryCache'\n\nexport function useIsFetching() {\n  const queryCache = useQueryCache()\n  const [state, setState] = React.useState({})\n\n  React.useEffect(() => {\n    return queryCache.subscribe(() => setState({}))\n  }, [])\n\n  return React.useMemo(() => state && queryCache.isFetching, [state])\n}\n","import React from 'react'\n\n//\n\nimport { useConfigContext } from './config'\nimport {\n  statusIdle,\n  statusLoading,\n  statusSuccess,\n  statusError,\n  useGetLatest,\n  Console,\n  uid,\n  useMountedCallback,\n  noop,\n} from './utils'\n\nconst getDefaultState = () => ({\n  status: statusIdle,\n  data: undefined,\n  error: null,\n})\n\nconst actionReset = {}\nconst actionLoading = {}\nconst actionResolve = {}\nconst actionReject = {}\n\nfunction mutationReducer(state, action) {\n  if (action.type === actionReset) {\n    return getDefaultState()\n  }\n  if (action.type === actionLoading) {\n    return {\n      status: statusLoading,\n    }\n  }\n  if (action.type === actionResolve) {\n    return {\n      status: statusSuccess,\n      data: action.data,\n    }\n  }\n  if (action.type === actionReject) {\n    return {\n      status: statusError,\n      error: action.error,\n    }\n  }\n  throw new Error()\n}\n\nexport function useMutation(mutationFn, config = {}) {\n  const [state, unsafeDispatch] = React.useReducer(\n    mutationReducer,\n    null,\n    getDefaultState\n  )\n\n  const dispatch = useMountedCallback(unsafeDispatch)\n\n  const getMutationFn = useGetLatest(mutationFn)\n\n  const getConfig = useGetLatest({\n    ...useConfigContext(),\n    ...config,\n  })\n\n  const latestMutationRef = React.useRef()\n\n  const mutate = React.useCallback(\n    async (\n      variables,\n      { onSuccess = noop, onError = noop, onSettled = noop, throwOnError } = {}\n    ) => {\n      const config = getConfig()\n\n      const mutationId = uid()\n      latestMutationRef.current = mutationId\n\n      const isLatest = () => latestMutationRef.current === mutationId\n\n      dispatch({ type: actionLoading })\n\n      let snapshotValue\n\n      try {\n        snapshotValue = await config.onMutate(variables)\n\n        let data\n\n        if (isLatest()) {\n          data = await getMutationFn()(variables)\n        }\n\n        if (isLatest()) {\n          await onSuccess(data, variables)\n        }\n\n        if (isLatest()) {\n          await config.onSuccess(data, variables)\n        }\n\n        if (isLatest()) {\n          await onSettled(data, null, variables)\n        }\n\n        if (isLatest()) {\n          await config.onSettled(data, null, variables)\n        }\n\n        if (isLatest()) {\n          dispatch({ type: actionResolve, data })\n        }\n\n        return data\n      } catch (error) {\n        if (isLatest()) {\n          Console.error(error)\n          await onError(error, variables, snapshotValue)\n        }\n\n        if (isLatest()) {\n          await config.onError(error, variables, snapshotValue)\n        }\n\n        if (isLatest()) {\n          await onSettled(undefined, error, variables, snapshotValue)\n        }\n\n        if (isLatest()) {\n          await config.onSettled(undefined, error, variables, snapshotValue)\n        }\n\n        if (isLatest()) {\n          dispatch({ type: actionReject, error })\n\n          if (throwOnError ?? config.throwOnError) {\n            throw error\n          }\n        }\n      }\n    },\n    [dispatch, getConfig, getMutationFn]\n  )\n\n  const reset = React.useCallback(() => dispatch({ type: actionReset }), [\n    dispatch,\n  ])\n\n  React.useEffect(() => {\n    if (getConfig().useErrorBoundary && state.error) {\n      throw state.error\n    }\n  }, [getConfig, state.error])\n\n  return [mutate, { ...state, reset }]\n}\n","import React from 'react'\n\n//\n\nimport { useQueryCache } from './queryCache'\nimport { useConfigContext } from './config'\nimport {\n  useUid,\n  isDocumentVisible,\n  Console,\n  useGetLatest,\n  useMountedCallback,\n} from './utils'\n\nexport function useBaseQuery(queryKey, queryVariables, queryFn, config = {}) {\n  const instanceId = useUid()\n\n  config = {\n    ...useConfigContext(),\n    ...config,\n  }\n\n  const queryCache = useQueryCache()\n\n  const queryRef = React.useRef()\n\n  const newQuery = queryCache._buildQuery(\n    queryKey,\n    queryVariables,\n    queryFn,\n    config\n  )\n\n  const useCachedQuery =\n    queryRef.current &&\n    typeof queryRef.current.queryHash === 'undefined' &&\n    typeof newQuery.queryHash === 'undefined'\n\n  // Do not use new query with undefined queryHash, if previous query also had undefined queryHash.\n  // Otherwise this will cause infinite loop.\n  if (!useCachedQuery) {\n    queryRef.current = newQuery\n  }\n\n  const query = queryRef.current\n\n  const [, unsafeRerender] = React.useState()\n\n  const rerender = useMountedCallback(unsafeRerender)\n\n  const getLatestConfig = useGetLatest(config)\n  const refetch = React.useCallback(\n    async ({ throwOnError, ...rest } = {}) => {\n      try {\n        return await query.fetch(rest)\n      } catch (err) {\n        if (throwOnError) {\n          throw err\n        }\n      }\n    },\n    [query]\n  )\n\n  query.suspenseInstance = {\n    onSuccess: data => getLatestConfig().onSuccess(data),\n    onError: err => getLatestConfig().onError(err),\n    onSettled: (data, err) => getLatestConfig().onSettled(data, err),\n  }\n\n  // After mount, subscribe to the query\n  React.useEffect(() => {\n    // Update the instance to the query again, but not as a placeholder\n    query.updateInstance({\n      id: instanceId,\n      onStateUpdate: () => rerender({}),\n      onSuccess: data => getLatestConfig().onSuccess(data),\n      onError: err => getLatestConfig().onError(err),\n      onSettled: (data, err) => getLatestConfig().onSettled(data, err),\n    })\n\n    return query.subscribe(instanceId)\n  }, [getLatestConfig, instanceId, query, rerender])\n\n  React.useEffect(() => {\n    // Perform the initial fetch for this query if necessary\n    if (\n      !getLatestConfig().manual && // Don't auto fetch if config is set to manual query\n      !query.wasPrefetched && // Don't double fetch for prefetched queries\n      !query.wasSuspended && // Don't double fetch for suspense\n      query.state.isStale && // Only refetch if stale\n      (getLatestConfig().refetchOnMount || query.instances.length === 1)\n    ) {\n      refetch().catch(Console.error)\n    }\n\n    query.wasPrefetched = false\n    query.wasSuspended = false\n  }, [getLatestConfig, query, refetch])\n\n  // Handle refetch interval\n  React.useEffect(() => {\n    const query = queryRef.current\n    if (\n      config.refetchInterval &&\n      (!query.currentRefetchInterval ||\n        // shorter interval should override previous one\n        config.refetchInterval < query.currentRefetchInterval)\n    ) {\n      query.currentRefetchInterval = config.refetchInterval\n      clearInterval(query.refetchIntervalId)\n      query.refetchIntervalId = setInterval(() => {\n        if (isDocumentVisible() || config.refetchIntervalInBackground) {\n          refetch().catch(Console.error)\n        }\n      }, config.refetchInterval)\n\n      return () => {\n        clearInterval(query.refetchIntervalId)\n        delete query.refetchIntervalId\n        delete query.currentRefetchInterval\n      }\n    }\n  }, [config.refetchInterval, config.refetchIntervalInBackground, refetch])\n\n  return {\n    ...query.state,\n    config,\n    query,\n    refetch,\n  }\n}\n","import { useBaseQuery } from './useBaseQuery'\nimport { getQueryArgs, handleSuspense } from './utils'\n\nexport function useQuery(...args) {\n  const query = useBaseQuery(...getQueryArgs(args))\n\n  handleSuspense(query)\n\n  return query\n}\n","import React from 'react'\n\n//\n\nimport { useBaseQuery } from './useBaseQuery'\nimport { getQueryArgs, handleSuspense } from './utils'\n\nexport function usePaginatedQuery(...args) {\n  let [queryKey, queryVariables, queryFn, config = {}] = getQueryArgs(args)\n\n  const lastDataRef = React.useRef()\n\n  if (!queryKey) {\n    lastDataRef.current = undefined\n  }\n\n  // If latestData is set, don't use initialData\n  if (typeof lastDataRef.current !== 'undefined') {\n    delete config.initialData\n  }\n\n  const query = useBaseQuery(queryKey, queryVariables, queryFn, config)\n\n  let { data: latestData, status } = query\n\n  React.useEffect(() => {\n    if (status === 'success' && typeof latestData !== 'undefined') {\n      lastDataRef.current = latestData\n    }\n  }, [latestData, status])\n\n  let resolvedData = latestData\n\n  if (typeof resolvedData === 'undefined') {\n    resolvedData = lastDataRef.current\n  }\n\n  if (typeof resolvedData !== 'undefined') {\n    status = 'success'\n  }\n\n  const paginatedQuery = {\n    ...query,\n    resolvedData,\n    latestData,\n    status,\n  }\n\n  handleSuspense(paginatedQuery)\n\n  return paginatedQuery\n}\n","import React from 'react'\n\n//\n\nimport { useBaseQuery } from './useBaseQuery'\nimport { getQueryArgs, useGetLatest, handleSuspense } from './utils'\n\nexport function useInfiniteQuery(...args) {\n  const queryInfoRef = React.useRef()\n  let [queryKey, queryVariables, queryFn, config = {}] = getQueryArgs(args)\n\n  const { getFetchMore } = config\n  const getGetFetchMore = useGetLatest(getFetchMore)\n\n  // The default queryFn will query all pages and map them together\n  const originalQueryFn = queryFn\n\n  queryFn = async () => {\n    const data = []\n    const pageVariables = [...queryInfoRef.current.query.pageVariables]\n    const rebuiltPageVariables = []\n\n    do {\n      const args = pageVariables.shift()\n\n      if (!data.length) {\n        // the first page query doesn't need to be rebuilt\n        data.push(await originalQueryFn(...args))\n        rebuiltPageVariables.push(args)\n      } else {\n        // get an up-to-date cursor based on the previous data set\n        const nextCursor = getGetFetchMore()(data[data.length - 1], data)\n\n        // break early if there's no next cursor\n        // otherwise we'll start from the beginning\n        // which will cause unwanted duplication\n        if (!nextCursor) {\n          break\n        }\n\n        const pageArgs = [\n          // remove the last argument (the previously saved cursor)\n          ...args.slice(0, -1),\n          nextCursor,\n        ]\n\n        data.push(await originalQueryFn(...pageArgs))\n        rebuiltPageVariables.push(pageArgs)\n      }\n    } while (pageVariables.length)\n\n    queryInfoRef.current.query.canFetchMore = getGetFetchMore()(\n      data[data.length - 1],\n      data\n    )\n    queryInfoRef.current.query.pageVariables = rebuiltPageVariables\n\n    return data\n  }\n\n  const queryInfo = useBaseQuery(queryKey, queryVariables, queryFn, config)\n\n  if (\n    typeof queryInfo.query.canFetchMore === 'undefined' &&\n    typeof queryInfo.data !== 'undefined'\n  ) {\n    queryInfo.query.canFetchMore = getGetFetchMore()(\n      queryInfo.data[queryInfo.data.length - 1],\n      queryInfo.data\n    )\n  }\n\n  queryInfoRef.current = queryInfo\n\n  let {\n    refetch,\n    data = [],\n    query: { canFetchMore },\n  } = queryInfo\n\n  // Here we seed the pageVariabes for the query\n  if (!queryInfo.query.pageVariables) {\n    queryInfo.query.pageVariables = [\n      [...queryInfo.query.queryKey, ...queryInfo.query.queryVariables],\n    ]\n  }\n\n  const fetchMore = React.useCallback(\n    (fetchMoreInfo = queryInfoRef.current.query.canFetchMore) =>\n      queryInfoRef.current.query.canFetchMore\n        ? refetch({\n            force: true,\n            __queryFn: async (...args) => {\n              try {\n                queryInfoRef.current.query.setState(old => ({\n                  ...old,\n                  isFetchingMore: true,\n                }))\n\n                const newArgs = [...args, fetchMoreInfo]\n                queryInfoRef.current.query.pageVariables.push(newArgs)\n\n                const data = [\n                  ...queryInfoRef.current.data,\n                  await originalQueryFn(...newArgs),\n                ]\n\n                queryInfoRef.current.query.canFetchMore = getGetFetchMore()(\n                  data[data.length - 1],\n                  data\n                )\n\n                return data\n              } finally {\n                queryInfoRef.current.query.setState(old => ({\n                  ...old,\n                  isFetchingMore: false,\n                }))\n              }\n            },\n          })\n        : void 0,\n    [getGetFetchMore, originalQueryFn, refetch]\n  )\n\n  handleSuspense(queryInfo)\n\n  return {\n    ...queryInfo,\n    data,\n    canFetchMore,\n    fetchMore,\n  }\n}\n"]},"metadata":{},"sourceType":"module"}